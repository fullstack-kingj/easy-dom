{"./":{"url":"./","title":"前言","keywords":"","body":" 学习本套课程，需要你具备 HTML、CSS 以及 JavaScript 语法部分的基础。 使用 GitBook 在线阅读本课程 前言 本套课程共分为 8 个章节，从基础的概念到具体的用法，逐一详细的进行阐述。目的就是努力成为最好的 DOM 自学课程。 本套课程会一直更新，直到达到适合于所有人自学为止。 8 个章节内容，大体上可以被分为以下几个部分内容: 说明: 如果你已经掌握 DOM 中的部分内容，可以根据自己的情况选择性的进行学习。 第一部分: 概念 我们首先从第一章节概念入手，先掌握什么是 DOM，以及 DOM 中非常重要的概念 DOM 树结构。 这部分内容，是你学习 DOM 中后续内容的基础。概念清晰了，操作才会更顺手。学习概念，不仅仅只是单纯地阅读文字这么简单。要试着用自己的话来描述你所学习的概念，并把它发布到网络上，让别人替你检查，你对 DOM 概念的理解是否准确。 如果你不知道如何发布到网络上，可以加入底部的 QQ 讨论群，与其他人共同学习。 第二部分: 核心对象 DOM 解析 HTML 页面，最主要的是依靠 Document、Node 和 Element 这三个核心对象完成的。所以，第二章、第三章和第四章是分别学习这三个核心对象。 这部分内容，作者在编写的过程中，尽量按照 W3C DOM 的规范标准进行编写。可能，学习掌握起来有一些难度。 不过，不要灰心! 作者会在后续的更新中，加入大量适当的案例，帮助你更好地掌握这部分内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 第三部分: 样式操作 DOM 解析 HTML 页面，其中很大部分是对 CSS 样式的操作。如今的 HTML 页面显示的效果越加复杂，主要都是由 CSS 样式完成的。 所以，掌握如何获取和设置 CSS 样式也就显得很重要了。但是，技术知识和实际操作还是会存在一些差异，这些差异作者也会在后续的案例更新中进行补充。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 第四部分: 事件 事件，目前作为 DOM 操作中很主要的组成部分，也是你学习 DOM 技术必须要掌握的技术知识。所以，作者在第六章节，利用了大量篇幅来阐述有关事件的内容。 说明: 目前课程中有关事件一章，并没有罗列出所有事件的用法和应用场景。 第五部分: 表单 表单，本身就是作为 HTML 页面技术中很重要的一个组成部分。而 DOM 操作表单也就变得重要了。 目前，大部分初学者都可以简单地掌握 DOM 操作表单的方式。但，很难全面系统地掌握，而很多容易忽视的内容，往往都是开发中比较常用的。 第六部分: BOM BOM，原本是作为 JavaScript 三个组成部分的其中一个，但由于篇幅较少，作者将其纳入到 DOM 课程之中。 反馈 本套课程会尽量完善，编写过程中难免出现纰漏。你可以通过以下展示方式进行反馈，作者会根据反馈及时更新和修改。 交流 你可以扫描下方的二维码，加入本套课程的 QQ 讨论群，与其他童鞋一起学习交流。 版权 本套课程的文本内容免费开源，任何人都可以免费学习、分享，甚至可以进行修改。但需要注明作者及来源，并且不能用于商业。 本套课程采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-03 12:12:48 "},"chapter1/dom-summary.html":{"url":"chapter1/dom-summary.html","title":"第一章 DOM 是什么","keywords":"","body":"DOM 是什么 DOM 其实是个缩写，全称是 Document Object Model，被译为 文档对象模型。如下图所示: 其中 D 表示 Document，就是 DOM 将 HTML 页面解析为一个 文档。同时提供了 document 对象。 其次 O 表示 Object，就是 DOM 将 HTML 页面中每个元素解析为一个 对象。例如 元素在 DOM 中对应就是 HTMLBodyElement 对象。 最后 M 表示 Model，就是 DOM 中表示各个对象之间的关系。 模型（Model）主要是指 DOM 树结构。 DOM 是用来做什么的 DOM 被设计用于解析 HTML 页面文档，方便 JavaScript 语言通过 DOM 访问和操作 HTML 页面中的内容。 DOM 是由 W3C 组织定义标准规范，并且由各大浏览器厂商支持。严格意义上来讲，DOM 并非属于 JavaScript 语言。 在其他开发语言中，也支持 DOM 的标准规范，例如 PHP 语言。 我们之所以可以在 JavaScript 语言中使用 DOM，是因为各大浏览器将 DOM 的标准规范内容封装成了 JavaScript 语言所支持的形式。 对于 DOM 中的对象，我们只有调用的权限，没有修改的权限，也说明了这个问题。 DOM 是如何解析 HTML 页面的呢 浏览器加载并运行 HTML 页面后，会创建 DOM 结构。由于 DOM 中的内容被封装成了 JavaScript 语言中的对象，所以我们可以使用 JavaScript 语言通过 DOM 结构来访问和操作 HTML 页面中的内容。 换句话讲，DOM 可以理解为是 HTML 页面与 JavaScript 语言之间的一个桥梁（当然，这种理解并不准确）。如下图所示: DOM 的定义 由于 DOM 的标准规范是由 W3C 组织起草并定义的，所以 W3C 对 DOM 的定义是目前最权威的解释。 下面这段英文描述，就是 W3C 对 DOM 的定义原文: The Document Object Model is a platform and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure and style of documents. The document can be further processed and the results of that processing can be incorporated back into the presented page. 下面这段是本人的翻译（仅供参考）: DOM 是一个独立于任何语言和平台的接口，允许任何语言或脚本动态地访问和更新 HTML 文档的内容、结构和样式。该 HTML 页面可以进一步处理，并且该处理的结果可以被合并到所呈现的 HTML 页面中。 DOM 标准是独立的 通过 W3C 的定义，我们可以知道 DOM 是不属于任何开发语言的。当然，DOM 也不会属于 JavaScript 语言。 任何一个开发语言，只要支持了 DOM 的标准规范，都可以通过 DOM 访问和操作 HTML 页面。 换句话讲，DOM 在不同开发语言中，有着不同的使用形式。但最核心的标准规范都是一样的，只是具体使用的开发语言的语法不同而已。 比如下面这段代码，就是 JavaScript 中的 DOM 内容: var btn = document.getElementById('btn'); var className = btn.className; className += ' animate'; btn.className = className; 上述示例代码通过 id 属性值 btn 获取页面中指定元素，并为该元素的 class 属性添加了名为 animate 的样式名称。 说明: 上述示例代码中 className += ' animate'; 中的空格，请参看第五章第六节《设置 class 属性》中的内容。 DOM 的作用 通过 W3C 的定义，我们还可以知道 DOM 主要是用来解析 HTML 页面的。也就是只要支持 DOM 的标准规范的开发语言，都可以通过 DOM 访问和更新 HTML 页面的内容、结构和样式。 早期的 DOM 除了可以访问和更新 HTML 页面外，还可以访问和更新 XML 文档。但目前 XML 文档的使用场景越来越少，再加上 Web 前端开发需求越来越多,导致 DOM 主要用来访问和更新 HTML 页面了。 浏览器的支持 目前几乎所有的浏览器都支持 DOM 的内容。但是不是支持的是 W3C 对 DOM 的标准规范呢？ 浏览器和 W3C 谁更早 浏览器对 DOM 的支持远早于 W3C 定义 DOM 的标准规范。也就是说，在 W3C 定义 DOM 的标准规范之前，各大浏览器就支持了 DOM。 最早，是 Navigator 浏览器支持 DOM。但只是提供了 Document 对象的一些属性和方法。 后期，IE 浏览器也加入了对 DOM 的支持。但 IE 浏览器与 Navigator 浏览器所支持的 DOM 是有区别的。 这也是 DOM 在不同浏览器中的兼容问题。 而 W3C 组织定义 DOM 的标准规范，主要也是为了解决 DOM 在不同浏览器的差异问题。 虽然，自从 W3C 定义了 DOM 的标准规范后，浏览器的兼容问题好了很多。但，各大浏览器都或多或少地扩展了 W3C 定义的 DOM 标准。 在实际开发中，尽量使用 W3C 的 DOM 标准规范，以避免更多的浏览器兼容问题。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-03 12:18:09 "},"chapter1/dom-tree.html":{"url":"chapter1/dom-tree.html","title":"第二节 DOM 树结构","keywords":"","body":"DOM 树结构 DOM 之所以可以访问和更新 HTML 页面中的内容、结构和样式，是因为 DOM 将 HTML 页面解析为一个 树结构。 例如下面这段代码是一个简单的 HTML 页面源代码: 示例页面 这是一个示例页面 这是一个段落内容. 将上面的 HTML 页面绘制成 DOM 树结构，如下效果: 通过上面的 DOM 树结构，我们可以看到，Document 对象是作为 DOM 树结构的入口。再根据 DOM 树结构的特点，我们就可以定位到 HTML 页面中任意一个元素、属性或文本内容。 浏览器加载并运行 HTML 页面时，会创建 DOM 树结构这个模型。并且 DOM 树结构模型会被存储在浏览器的内存中。 说明: 当 HTML 页面内容过于庞大和复杂时，生成的 DOM 树结构就越复杂。进而，浏览器加载 HTML 页面的耗时就越长。 什么是节点 节点（Node）原本是网络术语，表示网络中的连接点。一个网络是由一些节点构成的集合。 在 DOM 树结构中，节点也是很重要的一个概念。简单来说，节点作为 DOM 树结构中的连接点，最终构成了完整的 DOM 树结构。 DOM 树结构中的节点 在 DOM 树结构中，主要由以下 4 种节点组成: 常量 值 描述 Node.DOCUMENT_NODE 9 文档节点，表示整个 HTML 页面（相当于 document 对象） Node.ELEMENT_NODE 1 元素节点，表示 HTML 页面中的标签（即 HTML 页面的结构） Node.ATTRIBUTE_NODE 2 属性节点，表示 HTML 页面中的开始标签包含的属性。在 DOM4 规范里Node 接口将不再实现这个元素属性 Node.TEXT_NODE 3 文本节点，表示 HTML 页面中的标签所包含的文本内容 除了上面 4 种常见的节点类型以外，DOM 树结构中还具有很多节点类型。如下图表所示: 常量 值 描述 Node.PROCESSING_INSTRUCTION_NODE 7 一个用于XML文档的 ProcessingInstruction ，例如 声明 Node.COMMENT_NODE 8 Comment 节点 Node.DOCUMENT_TYPE_NODE 10 DocumentType 节点。例如 就是用于 HTML5 的 Node.DOCUMENT_FRAGMENT_NODE 11 DocumentFragment 节点 还有一些节点类型，目前已被废弃（不再使用）。如下图表所示: 常量 值 描述 Node.CDATA_SECTION_NODE 4 CDATASection。 在 DOM4 规范里被移除 Node.ENTITY_REFERENCE_NODE 5 XML 实体引用节点。 在 DOM4 规范里被移除 Node.ENTITY_NODE 6 XML 节点。 在 DOM4 规范中被移除 Node.NOTATION_NODE 12 XML 节点。 在 DOM4 规范里被移除 说明: 上述图表摘自 Mozilla 开发者社区。 DOM 节点树结构 通过节点概念，我们可以将原本的 DOM 树结构改成 DOM 节点树结构进行表示。如下图所示: 在 DOM 的标准规范中，提供了 Node 对象。该对象主要依靠 DOM 节点树结构中的常见 4 种节点类型，来访问和更新 HTML 页面中的内容。 关于 Node 对象，我们会在后面的章节中学习。 节点之间的关系 DOM 中的 M 表示 Model（模型），也可以用来表示 DOM 节点树结构中节点之间的关系。 在 DOM 节点树结构中，主要具有以下三层关系。 父级与子级 如果我们将 HTML 页面中某一个元素作为父级的话，那包含在该元素内的第一层所有元素都可以称为该元素的子级。 例如，我们来看一下下面这个 DOM 节点树结构: 在上面的 DOM 节点树结构中， 元素相对于 和 元素作为父级， 和 元素相对于 元素作为子级。 祖先与后代 如果我们将 HTML 页面中某一个元素作为祖先的话，那包含在该元素内的所有元素（除子级之外的）都可以称为该元素的后代。 例如，我们来看一下下面这个 DOM 节点树结构: 在上面的 DOM 节点树结构中， 元素相对于 、、 和 元素作为祖先，、、 和 元素相对于 元素作为后代。 兄弟关系 具有相同父级元素的两个或几个元素之间就是兄弟关系。例如，我们来看一下下面这个 DOM 节点树结构: 在上面的 DOM 节点树结构中， 和 元素就是兄弟关系。因为它们具有相同的父级元素 。 值得注意的是: 和 元素并不是兄弟关系。因为它们的父级元素并不是同一个元素。 DOM 访问和更新 HTML 页面中的内容，主要依靠 DOM 节点树结构中的以上三种节点关系完成。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-03 12:42:50 "},"chapter2/document-object.html":{"url":"chapter2/document-object.html","title":"第二章 Document 对象","keywords":"","body":"Document 对象是 DOM 的标准规范中比较重要的对象之一。该对象提供了访问和更新 HTML 页面内容的属性和方法。 Document 对象的作用 Document 对象作为 DOM 访问和更新 HTML 页面内容的入口。简单来说，我们可以把 Document 对象理解为在 DOM 的标准规范中代表 HTML 页面。（当然，这种说法并不准确） Document 对象提供的属性和方法，可以实现定位 HTML 页面中的元素，或者创建新的元素等功能。 测试 Document 对象 我们可以通过 console.log 方法将 Document 对象打印，测试 Document 对象中提供了哪些属性和方法: console.log(document); 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: 我们会发现 console 会将 HTML 页面的源代码打印出来。这个结果充分地说明了 Document 对象在 DOM 的标准规范中代表整个 HTML 页面。 换句话讲，DOM 访问和更新 HTML 页面内容主要依靠 Document 对象作为入口。 Document 对象的属性和方法一览 在 DOM 的标准规范中，Document 对象的属性和方法被定义在了 prototype 原型中。所以，我们想要查看 Document 对象中具有哪些属性和方法，可以打印 Document 对象的 protoype 进行查看。 console.log(Document.prototype); 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: URL:(...) activeElement:(...) adoptNode:function adoptNode() anchors:(...) append:function append() applets:(...) baseURI:(...) body:(...) characterSet:(...) charset:(...) childElementCount:(...) childNodes:(...) children:(...) close:function close() contentType:(...) cookie:(...) createAttribute:function createAttribute() createElement:function createElement() createEvent:function createEvent() createExpression:function createExpression() createNSResolver:function createNSResolver() createNodeIterator:function createNodeIterator() createProcessingInstruction:function createProcessingInstruction() createRange:function createRange() createTextNode:function createTextNode() createTreeWalker:function createTreeWalker() currentScript:(...) defaultView:(...) designMode:(...) dir:(...) doctype:(...) documentElement:(...) documentURI:(...) domain:(...) firstChild:(...) firstElementChild:(...) fonts:(...) forms:(...) getElementById:function getElementById() getElementsByClassName:function getElementsByClassName() getElementsByName:function getElementsByName() getElementsByTagName:function getElementsByTagName() getSelection:function getSelection() hasFocus:function hasFocus() head:(...) hidden:(...) images:(...) implementation:(...) importNode:function importNode() inputEncoding:(...) isConnected:(...) lastChild:(...) lastElementChild:(...) lastModified:(...) links:(...) nextSibling:(...) nodeName:(...) nodeType:(...) nodeValue:(...) open:function open() ownerDocument:(...) parentElement:(...) parentNode:(...) prepend:function prepend() previousSibling:(...) querySelector:function querySelector() querySelectorAll:function querySelectorAll() readyState:(...) referrer:(...) registerElement:function registerElement() rootElement:(...) scripts:(...) scrollingElement:(...) selectedStylesheetSet:(...) styleSheets:(...) textContent:(...) title:(...) visibilityState:(...) write:function write() writeln:function writeln() 我们可以看到，Document 对象提供的属性和方法还是比较多的。但在实际开发中，比较常用的属性和方法并没有太多。 关于 Document 对象的具体用法，我们在后面的章节中学习。 Document 对象的继承链 Document 对象是继承于 Node 对象的。Node 对象也是 DOM 的标准规范中非常重要的对象之一，而 Node 对象又是继承于 EventTarget 对象。 我们可以通过以下代码来测试 Document 对象的继承链: console.log(Document.prototype instanceof Node); console.log(Node.prototype instanceof EventTarget); console.log(Document.prototype instanceof EventTarget); Document 对象的属性和方法多是继承于 Node 对象和 EventTarget 对象的。当然，也有一部分属性和方法是实现了 HTMLDocument 接口的。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:37:13 "},"chapter2/get-elements.html":{"url":"chapter2/get-elements.html","title":"第二节 定位页面元素","keywords":"","body":"Document 对象提供了属性和方法实现定位页面元素功能，这也是 DOM 的标准规范中 Document 对象的主要应用之一。 定位页面元素方法 目前 Document 对象提供实现定位页面元素的方法具有如下几种: getElementById()方法：通过页面元素的 id 属性值定位元素。 getElementsByName()方法：通过页面元素的 name 属性值定位元素。 getElementsByTagName()方法：通过页面元素的元素名定位元素。 getElementsByClassName()方法：通过页面元素的 class 属性值定位元素。 querySelector()方法：通过 CSS 选择器定位第一个匹配的元素。 querySelectorAll()方法：通过 CSS 选择器定位所有匹配的元素。 接下来，我们就一一进行学习。 通过元素的 ID 属性值定位元素 HTML 页面元素的 id 属性的特点是唯一、不可重复的，所以通过这种方式定位的 HTML 页面元素也是唯一的。 其语法格式如下: element = document.getElementById(id); 在上述语法中，id 是参数，表示所要定位元素的 id 属性值，是一个大小写敏感的字符串。element 是返回值，表示定位的元素，是一个 Element 对象。 值得注意的是: 如果 HTML 页面中不存在具有该 id 属性值的元素，则返回 null。 下面是使用 getElementById() 方法的示例代码: var btn = document.getElementById('btn'); // 获取定位元素的 class 属性值 var className = btn.className; // 添加 animate 动画样式 className += ' animate'; // 将新的 class 属性值设置 btn.className = className; 上述代码通过 getElementById() 方法定位 HTML 页面中 id 属性值为 btn 的元素，并为其元素的 class 属性添加 animate 样式。 通过元素的 name 属性值定位元素 其语法格式如下: elements = document.getElementsByName(name); 在上述语法中，name 是参数，表示所要定位元素的 name 属性值，是一个大小写敏感的字符串。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByName() 方法的示例代码: var elems = document.getElementsByName('btn'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByName() 方法定位 HTML 页面中 name 属性值为 btn 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 通过元素的元素名定位元素 其语法格式如下: elements = document.getElementsByTagName(name); 在上述语法中，name 是参数，表示所要定位元素的元素名，符号”*”表示所有元素。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByTagName() 方法的示例代码: var elems = document.getElementsByTagName('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByTagName() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 通过元素的 class 属性值定位元素 其语法格式如下: elements = document.getElementsByClassName(names); 在上述语法中，names 是参数，表示所要定位元素的 class 属性值列表，class 名称通过空格分隔。 值得注意的是: names 参数可以是一个样式属性名称，也可以是多个样式属性名称。 elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByClassName() 方法的示例代码: var elems = document.getElementsByClassName('btn'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByClassName() 方法定位 HTML 页面中 class 属性值为 btn 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 兼容 IE 8 及之前版本的浏览器 getElementsByClassName() 方法只支持 IE 9 版本及之后版本的浏览器。也就是说，该方法并不支持 IE 8 及之前版本的浏览器。 下图是不同浏览器的不同版本对 getElementsByClassName() 方法的支持情况: 由于国内的生产环境中，依旧存在使用 IE 8 及之前版本浏览器的情况。所以，我们需要自定义 getElementsByClassName() 方法解决浏览器的兼容问题。 function getElementsByClassName(element, names) { } 上述自定义兼容方法接受两个参数，element 参数表示调用 getElementsByClassName() 方法的对象（目前为 Document 对象），names 参数表示所要定位元素的 class 属性值列表。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 } } 这里我们要优先使用 W3C 规范的方法。所以，需要先判断当前浏览器环境是否存在 getElementsByClassName() 方法。 如果存在，就使用原本的 getElementsByClassName() 方法。如果不存在，就使用自定义代码来实现。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 // 获取所有后代元素节点 var elements = element.getElementsByTagName('*'); // 定义空数组 var result = []; var element, classNameStr, flag; // 将样式名称改为数组类型 names = names.split(' '); // 循环遍历所有元素节点 for (var i=0; element = elements[i]; i++) { // 获取每个元素节点的样式名称 classNameStr = ' ' + element.className + ' '; // 开启开关 flag = true; // 循环遍历所有的样式名称 for (var j=0, name; name = names[j]; j++) { // 判断当前元素节点的样式名称中是否包含指定的样式名称 if (classNameStr.indexOf(' ' + name + ' ') == -1){ // 如果不包含，则关闭开关，并且结束循环 flag = false; break; } } // 判断当前元素节点是否包含指定样式名称 if (flag) { // 如果包含，则将当前元素节点添加到数组中 result.push(element); } } // 返回数组(所有包含指定样式名称的元素节点) return result; } } 通过 CSS 选择器定位元素 CSS 中的选择器可以很便利地定位 HTML 页面元素，DOM 的标准规范中也提供类似的方法。 querySelector(): 定位匹配选择器的第一个元素。 querySelectorAll(): 定位匹配选择器的所有元素。 querySelector() 方法 其语法格式如下: element = document.querySelector(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。element 是返回值，表示定位元素的集合，匹配的第一个元素。 下面是使用 querySelector() 方法的示例代码: var btn = document.querySelector(’#btn'); // 获取定位元素的 class 属性值 var className = btn.className; // 添加 animate 动画样式 className += ' animate'; // 将新的 class 属性值设置 btn.className = className; 上述代码通过 querySelector() 方法定位 HTML 页面中 id 属性值为 btn 的元素，并为其元素的 class 属性添加 animate 样式。 querySelectorAll() 方法 其语法格式如下: elements = document.querySelectorAll(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 querySelectorAll() 方法的示例代码: var elems = document.querySelectorAll('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 querySelectorAll() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 节点集合 NodeList NodeList 是一组元素节点的集合，每个节点具有相应的索引值（从 0 开始的数字，类似于数组）。 元素节点在 NodeList 集合中存储的顺序与它们在 HTML 页面中的顺序保持一致。 NodeList 的属性 length 表示 NodeList 对象中包含的节点个数。方法 item(index) 表示返回 NodeList 对象中指定索引的节点。如果索引值越界,则返回 null。 NodeList 集合分为两种: 动态 NodeList 和静态 NodeList。 动态的 NodeList 集合 所谓动态的 NodeList 集合，就是如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。 以下几种定位 HTML 页面元素的方法返回的都是动态的 NodeList 集合。 getElementsByName()方法：通过页面元素的 name 属性值定位元素。 getElementsByTagName()方法：通过页面元素的元素名定位元素。 getElementsByClassName()方法：通过页面元素的 class 属性值定位元素。 我们可以通过以下示例代码，体验动态 NodeList 集合的特点: var elems = document.getElementsByTagName('button'); console.log(elems.length);// 输出 3 // 添加一个新的button按钮 var btn = document.createElement('button'); btn.setAttribute('class','button'); var text = document.createTextNode('New Button'); btn.appendChild(text); var div = document.getElementsByClassName('button-group')[0]; div.appendChild(btn); console.log(elems.length);// 输出 4 上述代码通过 getElementsByTagName() 方法定位 HTML 页面中所有的 button 元素，测试打印 button 元素的个数是 3 个。 然后，我们创建一个新的 button 元素，并且将其添加到 HTML 页面中，再测试打印 button 元素的个数是 4 个。 值得注意的是: 我们在第二次测试打印 button 元素的个数时，并没有重新定位 HTML 页面中的 button 元素。 静态 NodeList 集合 所谓静态 NodeList 集合，就是对文档对象模型的任何改动都不会影响集合的内容。 querySelectorAll() 方法定位 HTML 页面元素所返回的 NodeList 集合就是静态 NodeList 集合。 我们可以通过以下示例代码，体验静态 NodeList 集合的特点: var elems = document.querySelectorAll('button'); console.log(elems.length);// 输出 3 // 添加一个新的button按钮 var btn = document.createElement('button'); btn.setAttribute('class','button'); var text = document.createTextNode('New Button'); btn.appendChild(text); var div = document.getElementsByClassName('button-group')[0]; div.appendChild(btn); console.log(elems.length);// 输出 3 上述代码通过 querySelectorAll() 方法定位 HTML 页面中所有的 button 元素，测试打印 button 元素的个数是 3 个。 然后，我们创建一个新的 button 元素，并且将其添加到 HTML 页面中，再测试打印 button 元素的个数依旧是 3 个。 定位页面元素属性 Document 对象也提供了一些属性，来定位 HTML 页面中一些比较特殊的元素。 documentElement：获取 HTML 页面中的 元素。 head：获取 HTML 页面中的 元素。 title：获取 HTML 页面中的 元素。 body：获取 HTML 页面中的 元素。 links：获取 HTML 页面中的所有 元素。 images：获取 HTML 页面中的所有 元素。 我们可以定义一个包含以上元素的 HTML 页面，然后通过以下示例代码进行测试: console.log(document.documentElement); console.log(document.head); console.log(document.body); console.log(document.title); console.log(document.links); console.log(document.images); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:37:39 "},"chapter2/create-element.html":{"url":"chapter2/create-element.html","title":"第三节 创建页面元素","keywords":"","body":"Document 对象提供了可以创建元素节点、属性节点和文本节点的方法，方便 DOM 更新 HTML 页面中的元素。 创建元素节点 Document 对象提供了 createElement() 方法创建元素节点，其语法格式如下: element = document.createElement(tagName); 上述语法格式中，tagName 是参数，表示创建元素的元素名称。element 是返回值，表示创建的元素。 值得注意的是: createElement() 方法优先将参数转换为小写。 下面是使用 createElement() 方法的示例代码: var div = document.getElementById('group'); // 创建新的元素节点 var elem = document.createElement('button'); div.appendChild(elem); 上述示例代码通过 createElement() 方法创建了 button 元素，并将其添加到 HTML 页面中。 创建文本节点 Document 对象提供了 createTextNode() 方法创建文本节点，其语法格式如下: textNode = document.createTextNode(data); 上述语法格式中，data 是参数，包含了放在文本节点中的内容，是一个字符串。textNode 是返回值，表示创建的文本节点。 下面是使用 createTextNode() 方法的示例代码: var div = document.getElementById('group'); // 创建新的元素节点 var elem = document.createElement('button'); // 创建文本节点 var text = document.createTextNode('New Button'); // 将文本节点添加到新的元素节点 elem.appendChild(text); // 将新的元素节点添加到父级元素节点 div.appendChild(elem); 上述示例代码先通过 createElement() 方法创建了 button 元素，再通过 createTextNode() 方法创建了一个新的文本节点，并将其添加到新创建的 button 元素中。 创建属性节点 Document 对象提供了 createAtrribute() 方法创建属性节点，其语法格式如下: attributeNode = document.createAttribute(name); 上述语法格式中，name 是参数，属性节点的属性名称。attributeNode 是返回值，表示创建的属性节点。 值得注意的是: 创建属性节点方法只具有属性名称，没有属性值。想要设置属性值需要通过 nodeValue 属性完成。 由于属性节点不是元素节点的子节点，不能使用添加子节点方式操作属性节点。想要添加属性节点需要通过 setAttributeNode() 方法完成。 下面是使用 createAtrribute() 方法的示例代码: var div = document.getElementById('group'); // 创建新的元素节点 var elem = document.createElement('button'); // 创建文本节点 var text = document.createTextNode('New Button'); elem.appendChild(text); // 创建属性节点 var attribute = document.createAttribute('class'); // 设置属性的值 attribute.nodeValue = 'button'; // 将属性节点添加到元素节点 elem.setAttributeNode(attribute); div.appendChild(elem); 上述示例代码先通过 createAtrribute() 方法创建了 ，再通过 createTextNode() 方法创建了一个新的文本节点，并将其添加到新创建的 button 元素中。最后，通过 createAttribute() 方法创建 class 属性节点，并设置了属性值为 button，再将该属性节点添加到新创建的 button 元素中。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 13:43:50 "},"chapter3/node-object.html":{"url":"chapter3/node-object.html","title":"第三章 Node 对象","keywords":"","body":"DOM 的标准规范中提供了 Node 对象，该对象主要提供了用于解析 DOM 节点树结构的属性和方法。 Node 对象的作用 DOM 树结构主要是依靠节点进行解析，称为 DOM 节点树结构。Node 对象是解析 DOM 节点树结构的主要入口。 Node 对象提供的属性和方法，可以实现遍历节点、插入节点和替换节点等操作。而这些操作也正是我们学习 Node 对象最为主要的目的。 Node 对象的继承链关系 Node 对象是继承于 EventTarget 对象的，EventTarget 是一个用于接收事件的对象。我们可以通过如下代码测试两者之间的继承关系: console.log(Node.prototype instanceof EventTarget); DOM 的标准规范中的 Document 对象和 Element 对象（后面的章节要学习的内容）都是继承于 Node 对象的。我们可以通过如下代码测试它们之间的继承关系: console.log(Document.prototype instanceof Node); console.log(Element.prototype instanceof Node); 测试 Node 对象 由于 Node 对象是 DOM 底层封装的对象，所以我们并不能通过直接打印 Node 对象来查看其属性或方法。 而是要通过打印 Node 对象的 prototype 原型属性来查看其属性或方法。 console.log(Node.prototype) 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:38:48 "},"chapter3/node-type.html":{"url":"chapter3/node-type.html","title":"第二节 判断节点类型","keywords":"","body":"Node 对象中提供了 nodeName、nodeType 和 nodeValue 分别可以用于获取指定节点的节点名称、节点类型和节点的值。 DOM 节点树结构中，我们实际开发最常见的节点有: 节点名称 含义 元素节点 表示 HTML 页面中的标签（即 HTML 页面的结构） 当访问 DOM 树时，需要从查找元素节点开始 属性节点 表示 HTML 页面中的开始标签包含的属性 文本节点 表示 HTML 页面中的标签所包含的文本内容 nodeName 属性 Node 对象的 nodeName 属性用于获取指定节点的节点名称。具体的语法结构如下: var str = node.nodeName; 在上述语法结构中，str 是一个存储了当前节点的节点名称的字符串。 值得注意的是: nodeName 是一个只读属性。 针对不同的节点类型，nodeName 返回的节点名称是不同的: 节点类型 nodeName 属性的值 Document 文档节点 \"#document\" Element 元素节点 元素节点的元素名 Attr 属性节点 属性节点的属性名 Text 文本节点 \"#text\" 如下代码示例，测试元素节点、属性节点和文本节点的 nodeName 的值: // 获取元素节点 var elemNode = document.getElementById('btn'); // 获取属性节点 var attrNode = elemNode.getAttributeNode('title'); // 获取文本节点 var textNode = elemNode.firstChild; console.log('元素节点的nodeName: ' + elemNode.nodeName); console.log('属性节点的nodeName: ' + attrNode.nodeName); console.log('文本节点的nodeName: ' + textNode.nodeName); nodeType 属性 Node 对象的 nodeType 属性用于获取指定节点的节点类型。具体的语法结构如下: var type = node.nodeType; 在上述语法结构中，type 是一个整数，其代表的是节点类型。 针对不同的节点类型，nodeType 返回的节点类型是不同的: 节点类型 nodeType 属性的值 Document 文档节点 9 Element 元素节点 1 Attr 属性节点 2 Text 文本节点 3 如下代码示例，测试元素节点、属性节点和文本节点的 nodeType 的值: // 获取元素节点 var elemNode = document.getElementById('btn'); // 获取属性节点 var attrNode = elemNode.getAttributeNode('title'); // 获取文本节点 var textNode = elemNode.firstChild; console.log('元素节点的nodeType: ' + elemNode.nodeType); console.log('属性节点的nodeType: ' + attrNode.nodeType); console.log('文本节点的nodeType: ' + textNode.nodeType); nodeValue 属性 Node 对象的 nodeValue 属性用于获取指定节点的节点值。具体的语法结构如下: var value = node.nodeValue; 在上述语法结构中，value 是一个包含当前节点的值的字符串。 针对不同的节点类型，nodeValue 返回的节点类型是不同的: 节点类型 nodeValue 属性的值 Document 文档节点 null Element 元素节点 null Attr 属性节点 属性节点的属性值 Text 文本节点 文本节点的内容 如下代码示例，测试元素节点、属性节点和文本节点的 nodeValue 的值: // 获取元素节点 var elemNode = document.getElementById('btn'); // 获取属性节点 var attrNode = elemNode.getAttributeNode('title'); // 获取文本节点 var textNode = elemNode.firstChild; console.log('元素节点的nodeValue: ' + elemNode.nodeValue); console.log('属性节点的nodeValue: ' + attrNode.nodeValue); console.log('文本节点的nodeValue: ' + textNode.nodeValue); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:13:37 "},"chapter3/loop-node.html":{"url":"chapter3/loop-node.html","title":"第三节 遍历节点","keywords":"","body":"Node 对象提供了一系列的属性和方法用来利用 DOM 节点树结构中节点的关系实现遍历其中的节点。 关于节点之间的关系，可以参考《DOM树结构》一节有关节点之间关系的内容。 获取父节点 通过 HTML 页面中指定元素查找其父级节点，我们可以使用 Node 对象的 parentNode 属性实现: pNode = node.parentNode; 在上述语法结构中，parentNode 属性返回指定节点的父节点。 值得注意的是: 一个元素节点的父节点，可能是一个元素节点，也可能是一个文档节点。 以下代码示例，就是通过 parentNode 属性获取指定节点的父节点，再实现其他操作的: var btn = document.getElementById('btn'); var parentNode = btn.parentNode; var className = parentNode.className; className += ' animate'; parentNode.className = className; 获取父元素节点 Node 对象除了提供了 parentNode 属性可以获取指定节点的父节点之外，还提供了 parentElement 属性获取指定节点的父元素节点。 parentElementNode = node.parentElement; 在上述语法结构中，parentElement 属性返回指定节点的父元素节点。 值得注意的是: 如果一个节点没有父节点，或者父节点不是一个元素节点的话，parentElement 属性返回 null。 以下代码示例，就是通过 parentElement 属性获取指定节点的父元素节点，再实现其他操作的: var btn = document.getElementById('btn'); var parentElement = btn.parentElement; var className = parentElement.className; className += ' animate'; parentElement.className = className; 父节点与父元素节点的区别 所谓父节点，并没有指定某个节点的父节点一定是哪个类型的节点。而父元素节点，指定了某个节点的父节点一定是元素节点。 parentNode: 获取指定节点的父节点，其父节点不一定是元素节点。 parentElement: 获取指定节点的父元素节点，其父节点必须是元素节点。 如果我们获取 元素的父节点的话，就是 document 文档节点。而 document 文档节点并不是一个元素节点。如下述代码示例: // 获取 元素 var html = document.documentElement; console.log('parentNode: ' + html.parentNode); console.log('parentElement: ' + html.parentElement); 上述代码示例，输出的结果如下: 获取子节点 通过 HTML 页面中指定元素查找其子节点，我们可以通过以下 Node 对象的属性实现: 属性名 描述 childNodes 获取指定节点的所有子节点 firstChild 获取指定节点的第一个子节点 lastChild 获取指定节点的最后一个子节点 值得注意的是: HTML 页面中某个元素的子节点不一定是唯一的。 获取所有子节点 Node 对象提供了 childNodes 属性用于获取 HTML 页面中指定节点的所有子节点: var ndList = Node.childNodes; 在上述语法结构中，childNodes 属性的返回值 ndList 是一个 NodeList 对象，并且为只读。该属性获取一个包含指定节点的所有子节点的集合。 值得注意的是: childNodes 属性返回的是一个动态的 NodeList 对象。有关动态 NodeList 的内容，请参考《定位页面元素》一节的内容。 以下代码示例，就是通过指定节点获取其所有子节点，再实现其他操作的: var parentNode = document.getElementById('parent'); var children = parentNode.childNodes; console.log(children); 上述代码示例，输出的结果如下: 我们会发现，获取到的所有子节点，除了真正的子节点 之外，还具有 4 个文本节点。 空白节点 主流浏览器解析 HTML 页面内容为 DOM 节点树结构时，会产生空文本的空白节点。这是由 HTML 页面源代码中的换行引起的: A Button A Button A Button 上述代码示例的 DOM 节点树结构如下图所示: 如果将 HTML 页面的源代码编写成一行时，这个空白节点的问题可以得到解决。但这种解决方式妨碍了我们代码的可读性，并不建议这样解决。 值得注意的是: IE 8 及之前版本的浏览器中不存在空白节点问题。 空白节点的解决方案 在开发中，空白节点的问题将 DOM 节点树结构的解析及操作增加了不少的难度和麻烦。我们这里提供一种比较简单有效的解决方式: 弃用 DOM 中 Node 对象用于获取指定节点的子节点和兄弟节点的属性。 通过使用 getElementsByTagName() 方法实现相应功能。 比如我们要查找 HTML 页面指定元素的所有子节点的话，我们按照如下代码示例实现: var parentNode = document.getElementById('parent'); var children = parentNode.getElementsByTagName('button'); console.log(children); 上述代码示例运行的结果如下: 关于 DOM 中为什么要具有空白节点以及更完整的解决方案，可以参考 Mozilla 社区的《DOM 中的空白符》。 获取第一个子节点 Node 对象提供了 firstChild 属性用于获取指定节点的第一个子节点: var first_child = node.firstChild; 在上述语法结构中，firstChild 属性返回的 first_child 表示当前节点的第一个子节点的引用。 值得注意的是: 如果当前节点无子节点，则 firstChild 属性返回 null。 以下代码示例，就是通过指定节点获取其第一个子节点，再实现其他操作的: var parentNode = document.getElementById('parent'); var firstChild = parentNode.firstChild; 通过上述代码示例，我们最终得到依旧是空白节点，而并非第一个子节点。 var parentNode = document.getElementById('parent'); var firstChild = parentNode.getElementsByTagName('button')[0]; console.log(firstChild); 通过 getElementsByTagName() 方法替换之后，所得到的节点才是真正的第一个节点。 获取最后一个节点 Node 对象提供了 lastChild 属性用于获取指定节点的最后一个子节点: var last_child = node.lastChild; 在上述语法结构中，lastChild 属性返回的 last_child 表示当前节点的最后一个子节点的引用。 值得注意的是: 如果当前节点无子节点，则 lastChild 属性返回 null。 以下代码示例，就是通过指定节点获取其最后一个子节点，再实现其他操作的: var parentNode = document.getElementById('parent'); var lastChild = parentNode.lastChild; 通过上述代码示例，我们最终得到依旧是空白节点，而并非最后一个子节点。 var parentNode = document.getElementById('parent'); var children = parentNode.getElementsByTagName('button'); var lastChild = children[children.length-1]; 通过 getElementsByTagName() 方法替换之后，所得到的节点才是真正的最后一个节点。 获取相邻兄弟节点 通过 HTML 页面中指定元素查找其相邻兄弟节点，我们可以通过以下 Node 对象的属性实现: 属性名 描述 previousSibling 获取指定节点的前面相邻兄弟节点 nextSibling 获取指定节点的后面相邻兄弟节点 获取相邻前面兄弟节点 Node 对象提供了 previousSibling 属性用于获取指定节点的前面相邻兄弟节点: previousNode = node.previousSibling; 在上述语法结构中，previousSibling 属性返回的 previousNode 表示当前节点的前一个兄弟节点。 值得注意的是: 如果当前节点无前一个兄弟节点，则 previousSibling 属性返回 null。 以下代码示例，就是通过指定节点获取其前面相邻兄弟节点，再实现其他操作的: var elem = document.getElementById('btn'); var previousSibling = elem.previousSibling; 通过上述代码示例，我们最终得到依旧是空白节点，而并非前面相邻兄弟节点。 // 判断获取的兄弟节点是否为元素节点 if ( previousSibling.nodeType != 1){ previousSibling = previousSibling.previousSibling; } 通过判断获取的节点类型是否为元素节点，实现如何获取真正的前面相邻兄弟节点。 获取相邻后面兄弟节点 Node 对象提供了 nextSibling 属性用于获取指定节点的后面相邻兄弟节点: nextNode = node.nextSibling; 在上述语法结构中，nextSibling 属性返回的 nextNode 表示当前节点的后一个兄弟节点。 值得注意的是: 如果当前节点无后一个兄弟节点，则 nextSibling 属性返回 null。 以下代码示例，就是通过指定节点获取其后面相邻兄弟节点，再实现其他操作的: var elem = document.getElementById('btn'); var nextSibling = elem.nextSibling; 通过上述代码示例，我们最终得到依旧是空白节点，而并非后面相邻兄弟节点。 // 判断获取的兄弟节点是否为元素节点 if ( nextSibling.nodeType != 1){ nextSibling = nextSibling.nextSibling; } 通过判断获取的节点类型是否为元素节点，实现如何获取真正的后面相邻兄弟节点。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:38:37 "},"chapter3/insert-node.html":{"url":"chapter3/insert-node.html","title":"第四节 插入节点","keywords":"","body":"Node 对象提供了一些用于向 HTML 页面插入节点的方法，通过这些方法我们可以实现向 HTML 页面新增元素，或者移动 HTML 页面中的元素。 appendChild() 方法 Node 对象提供的 appendChild() 方法可以向指定节点的子节点列表的最后添加一个新的子节点。其语法结构如下: var child = node.appendChild(child); 在上述语法结构中，appendChild() 方法的参数 child 表示添加的新的子节点，同时该子节点也是 appendChild() 方法的返回值。 我们可以通过如下代码示例，学习 appendChild() 方法的使用: var parent = document.getElementById('parent'); var button = document.createElement('button'); button.setAttribute('class','button'); var text = document.createTextNode('A New Button'); button.appendChild(text); // 将新节点添加到父节点中 parent.appendChild(button); 在上述代码示例中，我们创建了一个新的 元素，并且将这个 元素添加到指定节点的子节点列表的最后面。 值得注意的是: 如果我们是将 HTML 页面中原有的节点插入到指定节点的子节点列表的最后面，那这个被插入的节点会先从原有的位置移除，再插入到指定的位置。 如下代码示例，就是将 HTML 页面原有的节点插入到指定位置: var parent = document.getElementById('parent'); var button = document.getElementById('btn'); // 将新节点添加到父节点中 parent.appendChild(button); 值得注意的是: appendChild() 方法只能允许在同一个 HTML 页面中实现插入节点的功能，而不能实现跨 HTML 页面的插入节点的功能。 insertBefore() 方法 Node 对象除了提供了 appendChild() 方法可以实现插入节点之外，还提供了 insertBefore() 方法同样可以实现插入节点的功能。其语法结构如下: var insertedElement = parentElement.insertBefore(newElement, referenceElement); 由于 insertBefore() 方法实现的是将一个节点插入到指定节点的某个子节点的前面。所以，在上述语法结构中: 参数 referenceElement 表示指定节点的某个子节点 参数 newElement 表示插入的节点 调用 insertBefore() 方法的 parentElement 表示指定的节点 作为返回值的 insertedElement 表示被插入的节点，即 newElement 我们可以通过如下代码示例，学习 insertBefore() 方法的使用: // 获取目标父节点 var parentElement = document.getElementById('parent'); // 创建新节点 var newElement = document.createElement('button'); newElement.setAttribute('class','button'); var text = document.createTextNode('A New Button'); newElement.appendChild(text); // 获取目标节点 var referenceElement = document.getElementById('btn'); // 将新节点添加到父节点中 parentElement.insertBefore(newElement, referenceElement); 值得注意的是: 如果我们是将 HTML 页面中原有的节点插入到指定节点的某个子节点的前面，那这个被插入的节点会先从原有的位置移除，再插入到指定的位置。 如下代码示例，就是将 HTML 页面原有的节点插入到指定位置: // 获取目标父节点 var parentElement = document.getElementById('parent'); // 获取被插入的节点 var newElement = document.getElementById('button'); // 获取目标节点 var referenceElement = document.getElementById('btn'); // 将新节点添加到父节点中 parentElement.insertBefore(newElement, referenceElement); 值得注意的是: 如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。 关于 insertAfter() 方法 我们需要注意的是，Node 对象中并没有提供 insertAfter() 方法。所以，我们并不能像使用 jQuery 中的 insertAfter() 方法一样使用。 但是，如果我们在开发中需要 insertAfter() 方法的话，是可以利用 insertBefore() 方法来实现的。 实现思路其实就是利用 insertBefore() 方法将被插入的节点插入到指定节点的下一个相邻兄弟的前面，最终实现插入到指定节点的后面的效果。 parentElement.insertBefore(newElement, referenceElement.nextSibling); 但由于主流浏览器存在空白节点的问题，所以，在真正实现时不能简单地直接通过 nextSibling 属性来解决的。 最后，真正可以实现 insertAfter() 方法的主要逻辑如下: var nextElement = referenceElement.nextSibling; if(nextElement.nodeType === 3){ nextElement = nextElement.nextSibling; } parentElement.insertBefore(newElement, nextElement); 如果 referenceElement 没有下一个相邻的兄弟节点的话，那 referenceElement 一定是该子节点列表的最后一个子节点。这样 referenceElement.nextSibling 返回的值为 ull，newElement 就会被插入到子节点列表的最后面。 值得注意的是: 关于 insertAfter() 方法，我们这里只是提供了一个解决的思路。在具体使用时，可能封装的具体用法也会不同。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:15:21 "},"chapter3/remove-node.html":{"url":"chapter3/remove-node.html","title":"第五节 删除节点","keywords":"","body":"Node 对象提供了 removeChild() 方法实现从 HTML 页面中删除指定节点。其语法结构如下: var oldChild = node.removeChild(child); OR element.removeChild(child); 在上述语法结构中，调用 removeChild() 方法的 node 表示 child 参数的父节点，而 child 参数则表示要删除的那个节点。 oldChild 则用于存储要删除的节点的引用，即 oldChild === child。当然，如果我们需要完成的仅仅只是删除节点操作的话，并不需要定义变量来存储被删除的节点。 值得注意的是: 在上述语法结构中，如果 child 参数不是 node 的子节点的话，调用该方法时会报错。 我们可以通过如下代码示例，测试 removeChild() 方法的具体使用: // 获取父节点 var parent = document.getElementById('parent'); // 获取子节点 var child = document.getElementById('btn'); // 删除节点 parent.removeChild(child); 值得注意的是: 被删除的节点是否从内存中被销毁，Mozilla 社区有这样一段描述: 被移除的这个子节点仍然存在于内存中，只是没有添加到当前文档的 DOM 树中。 因此，你还可以把这个节点重新添加回文档中。当然，实现要用另外一个变量比如上述语法中的 oldChild 来保存这个节点的引用。 如果使用上述语法中的第二种方法，即没有使用 oldChild 来保存对这个节点的引用，则认为被移除的节点已经是无用的，在短时间内将会被内存管理回收。 根据 Mozilla 社区对 removeChild() 方法的描述，我们可以进行如下代码示例的尝试: // 获取父节点 var parent = document.getElementById('parent'); // 获取子节点 var child = document.getElementById('btn'); // 删除节点，并将删除的节点存储在 oldChild 变量中 var oldChild = parent.removeChild(child); // 将删除的节点再添加到父节点的子节点列表中 parent.appendChild(oldChild); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:15:58 "},"chapter3/replace-node.html":{"url":"chapter3/replace-node.html","title":"第六节 替换节点","keywords":"","body":"Node 对象提供了 replaceChild() 方法实现 HTML 页面中节点的替换功能。其语法结构如下: replacedNode = parentNode.replaceChild(newChild, oldChild); 在上述语法结构中，调用 replaceChild() 方法的 parentNode 表示被替换节点 oldChild 的父级节点。 参数 oldChild 则表示 HTML 页面中被替换的节点。replaceChild() 方法的返回值也是被替换的节点，即 oldChild == replaceNode。 参数 newChild 则表示用于替换的新节点。如果该节点已经存在于 DOM 节点树结构中的话，则它会被从原始位置删除。 我们可以通过如下代码示例，测试 replaceChild() 方法的具体使用: // 获取父节点 var parentNode = document.getElementById('parent'); // 创建新节点 var newChild = document.createElement('button'); newChild.setAttribute('class','button'); var text = document.createTextNode('A New Button'); newChild.appendChild(text); // 获取子节点 var oldChild = document.getElementById('btn'); // 替换节点 parentNode.replaceChild(newChild, oldChild); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:16:50 "},"chapter3/clone-node.html":{"url":"chapter3/clone-node.html","title":"第七节 复制节点","keywords":"","body":"Node 对象提供了 cloneNode() 方法实现 HTML 页面中节点的复制功能。其语法结构如下: var dupNode = node.cloneNode(deep); 在上述语法结构中，调用 cloneNode() 方法的 node 表示被克隆的节点，返回值 dupNode 表示克隆后的新节点。 参数 deep 则表示是否采用深度克隆。如果为 true，则该节点的所有后代节点也都会被克隆；如果为 false，则只克隆该节点本身。 值得注意的是: 参数 deep 如果默认不传递的话，值为 false。但在旧版本的浏览器中, 你始终需要指定 deep 参数。 我们可以通过如下代码示例，测试 replaceChild() 方法的具体使用: var parent = document.getElementById('parent'); var btn = document.getElementById('btn'); // 复制目标节点 var clone = btn.cloneNode(true); parent.appendChild(clone); 复制节点的注意事项 克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件，但不会拷贝那些使用 addEventListener() 方法或者 node.onclick = fn 这种用 JavaScript 动态绑定的事件。 在使用 Node.appendChild() 或其他类似的方法将拷贝的节点添加到文档中之前，那个拷贝节点并不属于当前文档树的一部分。也就是说，它没有父节点。 如果deep参数设为false，则不克隆它的任何子节点。该节点所包含的所有文本也不会被克隆，因为文本本身也是一个或多个的 Text 节点。 为了防止一个文档中出现两个 ID 重复的元素,使用 cloneNode() 方法克隆的节点在需要时应该指定另外一个与原 ID 值不同的 ID。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:17:37 "},"chapter3/textcontent-attr.html":{"url":"chapter3/textcontent-attr.html","title":"第八节 textContent 属性","keywords":"","body":"Node 对象提供了 textContent 属性实现获取或设置 HTML 页面中指定元素的文本内容。 获取文本内容 textContent 属性表示 HTML 页面指定节点及其后代节点的文本内容。其语法格式如下: var text = element.textContent; 在上述语法结构中，返回值 text 表示 element 节点及其后代节点的文本内容。 需要说明的是，在上述语法结构中，调用 textContent 属性的 element 表示元素节点。元素节点本身也是一个元素。 值得注意的是: 如果指定节点是 Document 文档节点的话，textContent 返回 null。 我们可以通过如下代码示例，测试如何通过 textContent 属性获取指定节点的文本内容: var pElement = document.getElementById('p'); console.log(pElement.textContent); 值得注意的是: 如果指定节点的后代节点也包含文本内容的话，那该节点调用 textContent 属性时，则会返回该节点及其所有后代节点的文本内容。 如下 HTML 页面结构: 这是一个段落内容。 如果我们通过上述 元素调用 textContent 属性的话，得到的结果并不是如下结果: 这是一个内容。 而是如下结果: 这是一个段落内容。 设置文本内容 通过 textContent 属性不仅可以获取 HTML 页面中指定节点及其后代节点的文本内容，还可以设置指定节点的文本内容。其语法结构如下: element.textContent = \"this is some sample text\"; 值得注意的是: 在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。 我们可以通过如下代码示例，测试如何通过 textContent 属性设置指定节点的文本内容: var btn = document.getElementById('btn'); btn.textContent = 'A New Button'; innerText 属性 IE 引入了 node.innerText 属性，意图类似 textContent。但有以下区别： textContent 会获取所有元素的内容，包括 和 元素，然而 innerText 不会。 innerText 意识到样式，并且不会返回隐藏元素的文本，而 textContent 会。 由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但 textContent 不会。 在 IE (小于等于 IE11 的版本) 中对 innerText 进行修改，不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点。 关于 innerText 属性的具体用法请参考 MSDN社区的相关说明.aspx)。 浏览器兼容问题解决方案 在实际开发中，我们需要尽量满足所有浏览器对文本内容操作的需求。所以，我们可以使用如下代码解决浏览器之间的兼容问题: function text(elem, text){ if(text){ elem.textContent ? elem.textContent = text : elem.innerText = text; }else{ if(elem.textContent){ // 表示其他浏览器 return elem.textContent; }else{ // 表示 IE 浏览器 return elem.innerText; } } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:18:00 "},"chapter4/element-object.html":{"url":"chapter4/element-object.html","title":"第四章 Element 对象","keywords":"","body":"DOM 的标准规范中提供了 Element 对象，该对象提供了 HTML 页面中所有元素所具有的属性和方法。 我们都知道 DOM 标准规范中提供了 Node 对象，主要是依靠 DOM 节点树结构访问和更新 HTML 页面的内容。而 DOM 标准规范中提供了 Element 对象，主要是依靠 DOM 元素树结构访问和更新 HTML 页面的内容。 值得注意的是: 所有的 HTML 页面的元素都是 HTMLElement 对象，而这个对象又是继承于 Element 对象的。 Element 对象的作用 HTML 页面中的标签，既是元素节点，又是元素。 如果我们将 HTML 页面中的标签当做元素节点的话，就是利用 DOM 节点树结构进行解析和操作。但是，有些情况利用 Node 对象实现比较复杂，例如属性节点的操作，而使用 Element 对象提供的属性和方法相对会简单一些。 我们可以简单地理解 Element 对象是 Node 对象的补充。当然，这种理解并不准确！ 通过 Element 对象，我们可以实现遍历元素、属性操作等操作。而这些操作也正是我们要学习 Element 对象的属性和方法。 测试 Element 对象 由于 Element 对象是 DOM 底层封装的对象，所以我们并不能通过直接打印 Element 对象来查看其属性或方法。 而是要通过打印 Element 对象的 prototype 原型属性来查看其属性或方法。 console.log(Element.prototype) 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: 上面运行后的结果只是部分内容，并不是全部内容。请自行测试！ Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:39:44 "},"chapter4/elements-tree.html":{"url":"chapter4/elements-tree.html","title":"第二节 DOM 元素树","keywords":"","body":"DOM 元素树结构与 DOM 节点树结构很相似，区别仅在于是利用节点解析 HTML 元素，还是利用元素解析 HTML 元素。 DOM 树结构 还记得下面这张图吗? 上图中的 HTML 页面源代码如下: 示例页面 这是一个示例页面 这是一个段落内容. DOM 之所以可以访问和更新 HTML 页面中的内容、结构和样式，是因为 DOM 将 HTML 页面解析为一个 树结构。 DOM 元素树 上述 HTML 页面示例代码，如果利用节点方式解析为 DOM 节点树结构 的话，如下所示: 如果利用元素方式解析为 DOM 元素树结构 的话，如下所示: 通过上图所示，我们发现 DOM 元素树结构与 DOM 节点树结构类似，同样在元素之间存在着某些固定的关系。 元素之间的关系 在 DOM 元素树结构中，主要具有以下三层关系。 父级与子级 如果我们将 HTML 页面中某一个元素作为父级的话，那包含在该元素内的第一层所有元素都可以称为该元素的子级。 例如，我们来看一下下面这个 DOM 元素树结构: 在上面的 DOM 节点树结构中， 元素作为父级， 和 元素作为子级。 祖先与后代 如果我们将 HTML 页面中某一个元素作为祖先的话，那包含在该元素内的所有元素（除子级之外的）都可以称为该元素的后代。 例如，我们来看一下下面这个 DOM 元素树结构: 在上面的 DOM 节点树结构中， 元素作为祖先，、、 和 元素作为后代。 兄弟关系 具有相同父级元素的两个或几个元素之间就是兄弟关系。例如，我们来看一下下面这个 DOM 元素树结构: 在上面的 DOM 元素树结构中， 和 元素就是兄弟关系。因为它们具有相同的父级元素 。 节点与元素的区别 利用节点解析 DOM 节点树结构时，我们会发现元素节点、属性节点和文本节点是独立存在的。 如果获取文本节点的话，文本节点是元素节点的子节点。所以，我们可以通过子节点方式得到指定的文本节点。 如果获取属性节点的话，由于属性节点不是元素节点的子节点。所以，并不能直接通过获取子节点的方式得到指定的属性节点。 而利用元素解析 DOM 元素树结构时，我们会发现元素、属性和文本是从属关系。什么意思呢? 我们可以简单地将属性和文本内容理解为是元素的一部分。 这样，我们获取属性或文本内容时，就可以通过元素的获取属性或获取文本内容的方法或属性来实现。 关于节点与元素的区别，我们可以通过以下示例代码来理解: // 节点方式获取属性节点 var btn = document.getElementById('btn'); var attrNode = btn.getAttributeNode('class'); var attrValue = attrNode.nodeValue; // 元素方式获取属性 var btn = document.getElementById('btn'); var attrValue = btn.getAttribute('class'); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:40:25 "},"chapter4/get-elements.html":{"url":"chapter4/get-elements.html","title":"第三节 定位页面元素","keywords":"","body":"Element 对象提供了属性和方法实现定位页面元素功能。该对象与 Document 对象提供的属性和方法实现定位页面元素功能的区别在于，Document 对象定位的是 HTML 页面中所有指定元素，而 Element 对象定位的是指定元素内所有指定元素。 定位页面元素方法 目前 Document 对象提供实现定位页面元素的方法具有如下几种: getElementsByTagName()方法：通过页面元素的元素名定位元素。 getElementsByClassName()方法：通过页面元素的 class 属性值定位元素。 querySelector()方法：通过 CSS 选择器定位第一个匹配的元素。 querySelectorAll()方法：通过 CSS 选择器定位所有匹配的元素。 接下来，我们就一一进行学习。 通过元素的元素名定位元素 其语法格式如下: elements = document.getElementsByTagName(name); 在上述语法中，name 是参数，表示所要定位元素的元素名，符号”*”表示所有元素。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByTagName() 方法的示例代码: var elems = document.getElementsByTagName('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByTagName() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 通过元素的 class 属性值定位元素 其语法格式如下: elements = document.getElementsByClassName(names); 在上述语法中，names 是参数，表示所要定位元素的 class 属性值列表，class 名称通过空格分隔。 值得注意的是: names 参数可以是一个样式属性名称，也可以是多个样式属性名称。 elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByClassName() 方法的示例代码: var elems = document.getElementsByClassName('btn'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByClassName() 方法定位 HTML 页面中 class 属性值为 btn 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 兼容 IE 8 及之前版本的浏览器 getElementsByClassName() 方法只支持 IE 9 版本及之后版本的浏览器。也就是说，该方法并不支持 IE 8 及之前版本的浏览器。 下图是不同浏览器的不同版本对 getElementsByClassName() 方法的支持情况: 由于国内的生产环境中，依旧存在使用 IE 8 及之前版本浏览器的情况。所以，我们需要自定义 getElementsByClassName() 方法解决浏览器的兼容问题。 function getElementsByClassName(element, names) { } 上述自定义兼容方法接受两个参数，element 参数表示调用 getElementsByClassName() 方法的对象（目前为 Document 对象），names 参数表示所要定位元素的 class 属性值列表。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 } } 这里我们要优先使用 W3C 规范的方法。所以，需要先判断当前浏览器环境是否存在 getElementsByClassName() 方法。 如果存在，就使用原本的 getElementsByClassName() 方法。如果不存在，就使用自定义代码来实现。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 // 获取所有后代元素节点 var elements = element.getElementsByTagName('*'); // 定义空数组 var result = []; var element, classNameStr, flag; // 将样式名称改为数组类型 names = names.split(' '); // 循环遍历所有元素节点 for (var i=0; element = elements[i]; i++) { // 获取每个元素节点的样式名称 classNameStr = ' ' + element.className + ' '; // 开启开关 flag = true; // 循环遍历所有的样式名称 for (var j=0, name; name = names[j]; j++) { // 判断当前元素节点的样式名称中是否包含指定的样式名称 if (classNameStr.indexOf(' ' + name + ' ') == -1){ // 如果不包含，则关闭开关，并且结束循环 flag = false; break; } } // 判断当前元素节点是否包含指定样式名称 if (flag) { // 如果包含，则将当前元素节点添加到数组中 result.push(element); } } // 返回数组(所有包含指定样式名称的元素节点) return result; } } 通过 CSS 选择器定位元素 CSS 中的选择器可以很便利地定位 HTML 页面元素，DOM 的标准规范中也提供类似的方法。 querySelector(): 定位匹配选择器的第一个元素。 querySelectorAll(): 定位匹配选择器的所有元素。 querySelector() 方法 其语法格式如下: element = document.querySelector(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。element 是返回值，表示定位元素的集合，匹配的第一个元素。 下面是使用 querySelector() 方法的示例代码: var btn = document.querySelector(’#btn'); // 获取定位元素的 class 属性值 var className = btn.className; // 添加 animate 动画样式 className += ' animate'; // 将新的 class 属性值设置 btn.className = className; 上述代码通过 querySelector() 方法定位 HTML 页面中 id 属性值为 btn 的元素，并为其元素的 class 属性添加 animate 样式。 querySelectorAll() 方法 其语法格式如下: elements = document.querySelectorAll(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 querySelectorAll() 方法的示例代码: var elems = document.querySelectorAll('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 querySelectorAll() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:40:39 "},"chapter4/loop-element.html":{"url":"chapter4/loop-element.html","title":"第四节 遍历元素","keywords":"","body":"Element 对象提供了一系列的属性和方法用来利用 DOM 元素树结构中元素的关系实现遍历其中的元素。 关于元素之间的关系，可以参考《DOM 元素树》一节有关元素之间关系的内容。 获取子元素 通过 HTML 页面中指定元素查找其子元素，我们可以通过以下 Element 对象的属性实现: 属性名 描述 children 获取指定元素的所有子元素 firstElementChild 获取指定元素的第一个子元素 lastElementChild 获取指定元素的最后一个子元素 值得注意的是: HTML 页面中某个元素的子元素不一定是唯一的。 获取所有子元素 Element 对象提供了 children 属性用于获取 HTML 页面中指定节点的所有子元素: var elList = element.children; 在上述语法结构中，children 属性的返回值 elList 是一个 HTMLCollection 对象，并且为只读。该属性获取一个包含指定元素的所有子元素的集合。 以下代码示例，就是通过指定元素获取其所有子元素，再实现其他操作的: var parentElem = document.getElementById('parent'); var children = parentElem.children; console.log(children); 获取所有子元素的个数 Element 对象提供了 childElementCount 属性用于获取指定元素的所有子元素的个数: var count = element.childElementCount; 在上述语法结构中，childElementCount 属性返回的 count 表示指定元素的所有子元素的个数。 以下代码示例，就是通过指定元素获取其所有子元素的个数，再实现其他操作的: var parentElem = document.getElementById('parent'); var count = parentElem.childElementCount; console.log(count); 获取第一个子元素 Element 对象提供了 firstElementChild 属性用于获取指定元素的第一个子元素: var first_child = element.firstElementChild; 在上述语法结构中，firstElementChild 属性返回的 first_child 表示当前元素的第一个子元素的引用。 值得注意的是: 如果当前元素无子节点，则 firstElementChild 属性返回 null。 以下代码示例，就是通过指定元素获取其第一个子元素，再实现其他操作的: var parentElem = document.getElementById('parent'); var firstChild = parentElem.firstElementChild; console.log(firstChild); 获取最后一个元素 Element 对象提供了 lastElementChild 属性用于获取指定元素的最后一个子元素: var last_child = node.lastElementChild; 在上述语法结构中，lastElementChild 属性返回的 last_child 表示当前元素的最后一个子元素的引用。 值得注意的是: 如果当前节点无子元素，则 lastElementChild 属性返回 null。 以下代码示例，就是通过指定元素获取其最后一个子元素，再实现其他操作的: var parentElem = document.getElementById('parent'); var lastChild = parentElem.lastElementChild; console.log(lastChild); 获取相邻兄弟元素 通过 HTML 页面中指定元素查找其相邻兄弟元素，我们可以通过以下 Element 对象的属性实现: 属性名 描述 previousElementSibling 获取指定元素的前面相邻兄弟元素 nextElementSibling 获取指定元素的后面相邻兄弟元素 获取相邻前面兄弟元素 Element 对象提供了 previousElementSibling 属性用于获取指定元素的前面相邻兄弟元素: previousElem = element.previousElementSibling; 在上述语法结构中，previousElementSibling 属性返回的 previousElem 表示当前元素的前一个兄弟元素。 值得注意的是: 如果当前节点无前一个兄弟元素，则 previousElementSibling 属性返回 null。 以下代码示例，就是通过指定元素获取其前面相邻兄弟元素，再实现其他操作的: var btn = document.getElementById('btn'); var previousElem = btn.previousElementSibling; console.log(previousElem); 获取相邻后面兄弟元素 Element 对象提供了 nextElementSibling 属性用于获取指定元素的后面相邻兄弟元素: nextElem = element.nextElementSibling; 在上述语法结构中，nextElementSibling 属性返回的 nextElem 表示当前元素的后一个兄弟元素。 值得注意的是: 如果当前节点无后一个兄弟元素，则 nextElementSibling 属性返回 null。 以下代码示例，就是通过指定元素获取其后面相邻兄弟元素，再实现其他操作的: var btn = document.getElementById('btn'); var nextElem = btn.nextElementSibling; console.log(nextElem); 浏览器兼容问题 上述 Element 对象的遍历元素属性中，除 children 外，其他属性均不支持 IE 8 及之前版本的浏览器: childElementCount firstElementChild lastElementChild previousElementSibling nextElementSbling 浏览器兼容问题解决方案 我们可以通过自定义 JavaScript 文件方式，实现浏览器兼容问题。如以下代码示例: /** * Adds support to IE8 for the following properties: * * Element.childElementCount * Element.firstElementChild * Element.lastElementChild * Element.nextElementSibling * Element.previousElementSibling */ (function(){ \"use strict\"; var patches = { firstElementChild: function(){ for(var nodes = this.children, n, i = 0, l = nodes.length; i = 0; --i) if(n = nodes[i], 1 === n.nodeType) return n; return null; }, nextElementSibling: function(){ var e = this.nextSibling; while(e && 1 !== e.nodeType) e = e.nextSibling; return e; }, previousElementSibling: function(){ var e = this.previousSibling; while(e && 1 !== e.nodeType) e = e.previousSibling; return e; }, childElementCount: function(){ for(var c = 0, nodes = this.children, n, i = 0, l = nodes.length; i 需要说明的是: 上述浏览器兼容问题的解决方案是由 Snippets 开源项目提供的。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:22:29 "},"chapter4/attr-operate.html":{"url":"chapter4/attr-operate.html","title":"第五节 属性操作","keywords":"","body":"Element 对象提供了一些方法实现 HTML 元素的属性操作，这种操作要比 Node 对象提供的方法操作属性节点要更便捷。 获取指定元素的属性 Element 对象提供了 getAttribute() 方法用于获取指定元素的属性值，其语法结构如下: var attribute = element.getAttribute(attributeName); 在上述语法结构中，调用 getAttribute() 方法的 element 表示指定的元素，传递的参数 attributeName 则表示指定的属性名，得到的是指定属性对应的值。 值得注意的是: 如果指定的属性不存在，则返回 null 或 \"\" （空字符串）。 我们可以通过以下示例代码，学习 getAttribute() 方法的具体使用: var btn = document.getElementById('btn'); var className = btn.getAttribute('class'); console.log(className); 设置指定元素的属性 Element 对象提供了 setAttribute() 方法用于设置指定元素的属性值，其语法结构如下: element.setAttribute(name, value); 在上述语法结构中，调用 setAttribute() 方法的 element 表示指定的元素，传递的参数 name 表示设置指定的属性名，value 表示设置指定属性的值。 值得注意的是: 如果该属性已经存在，则更新该值; 否则将添加一个新的属性用指定的名称和值。 我们可以通过以下示例代码，学习 setAttribute() 方法的具体使用: var btn = document.getElementById('btn'); var className = btn.getAttribute('class'); className += ' animate'; btn.setAttribute('class',className); 删除指定元素的属性 Element 对象提供了 removeAttribute() 方法用于删除指定元素的属性，其语法结构如下: element.removeAttribute(attrName); 在上述语法结构中，调用 removeAttribute() 方法的 element 表示指定的元素，传递的参数 attrName 则表示删除的属性名。 值得注意的是: 删除属性尽量使用 removeAttribute() 方法，而不是调用 setAttribute() 方法将指定属性的值设置为 null。 如果删除的属性不存在的话，不会引发任何异常。 我们可以通过以下示例代码，学习 removeAttribute() 方法的具体使用: var btn = document.getElementById('btn'); btn.removeAttribute('class'); 判断是否含有指定属性 Element 对象提供了 hasAttribute() 方法用于判断是否含有指定的属性，其语法结构如下: var result = element.hasAttribute(attrName); 在上述语法结构中，调用 hasAttribute() 方法的 element 表示指定的元素，传递的参数 attrName 则表示要判断的属性名。 而 result 则是 hasAttribute() 方法的返回值，是一个 Boolean 类型的值。如果结果为 true，则表示含有指定的属性；如果结果为 false，则表示不含有指定的属性。 我们可以通过以下示例代码，学习 hasAttribute() 方法的具体使用: var btn = document.getElementById('btn'); var result = btn.hasAttribute('class'); console.log(result); 判断是否含有属性 Element 对象提供了与 hasAttribute() 方法相似的 hasAttributes() 方法用于判断是否含有属性，其语法结构如下: var result = element.hasAttributes(); 在上述语法结构中，调用 hasAttribute() 方法的 element 表示指定的元素，result 则是 hasAttributes() 方法的返回值，是一个 Boolean 类型的值。 值得注意的是: 该方法在某些浏览器中，已被废弃。 我们可以通过以下示例代码，学习 hasAttributes() 方法的具体使用: var btn = document.getElementById('btn'); var result = btn.hasAttributes(); console.log(result); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:23:09 "},"chapter4/innerhtml-attr.html":{"url":"chapter4/innerhtml-attr.html","title":"第六节 innerHTML 属性","keywords":"","body":"Element 对象提供了 innerHTML 属性用于实现获取或设置 HTML 页面指定元素的 HTML 代码。 获取 HTML 代码 innerHTML 属性表示 HTML 页面指定元素后代的 HTML 代码，其语法结构如下: var content = element.innerHTML; 在上述语法结构中，作为返回值 content 表示描述元素后代的 HTML 语句。 需要说明的是，在上述语法结构中，调用 innerHTML 属性的 element 表示元素节点。元素节点本身也是一个元素。 我们可以通过以下示例代码，学习如何通过 innerHTML 属性获取指定元素的 HTML 语句: var parent = document.getElementById('parent'); var content = parent.innerHTML; console.log(content); 设置 HTML 代码 innerHTML 属性不仅提供了获取 HTML 页面中指定元素的后代 HTML 语句，还提供了设置 HTML 页面中指定元素的后代 HTML 语句。其语法结构如下: element.innerHTML = markup; 在上述语法结构中，markup 表示设置描述元素后代的 HTML 语句。 我们可以通过以下示例代码，学习如何通过 innerHTML 属性设置指定元素的 HTML 语句: var parent = document.getElementById('parent'); parent.innerHTML = 'A Button'; 不是 W3C 规范 尽管 innerHTML 属性不属于 W3C DOM 规范，但是它为完全替换元素内容提供了一个更加便捷的方式。 举个例子，可以通过如下代码完全删除文档内body的内容: document.body.innerHTML = \"\"; 值得注意的是: 因为 innerHTML 属性没有统一的标准，各浏览器厂商对它实现差别很大。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:23:26 "},"chapter5/get-inline-style.html":{"url":"chapter5/get-inline-style.html","title":"第五章 样式操作","keywords":"","body":"回顾什么是内联样式 所谓内联样式，就是通过 HTML 页面元素的 style 属性为当前元素定义 CSS 样式。 以下代码示例，就是通过 style 属性定义 CSS 内联样式: 这是一个段落内容. 值得注意的是: HTML 页面的结构与样式并没有有效分离 定义的 CSS 样式只针对当前元素有效 获取内联样式 由于设置内联样式的方式是利用 HTML 页面元素的 style 属性实现的，所以获取内联样式主要是依靠 DOM 中获取属性方式实现。 Element 对象的 getAttribute() 方法获取 style 属性的值。 通过 DOM 对象 HTMLElement 的 style 属性获取。 Element 对象的 getAttribute() 方法 Element 对象的 getAttribute() 方法的语法结构如下: var value = element.getAttribute('style'); 以上语法结构中调用 getAttribute() 方法的 element 表示 HTML 页面元素，传递的参数 style 表示属性名称，而返回值则是指定属性名对应的值（内联样式的声明内容）。 我们可以通过以下示例代码，学习如何通过 getAttribute() 方法获取内联样式: 这是一个段落内容. var pElem = document.getElementById('p1'); var style = pElem.getAttribute('style'); console.log(style); 上述示例代码的输出结果如下: DOM 对象的 style 属性 由于 DOM 规范标准中将 Document 对象定位的 HTML 页面元素解析为相应的对象，而这些对象都继承于 HTMLElement 对象。该对象提供了 style 属性，返回 CSSStyleDeclaration 对象。 我们可以通过以下示例代码，学习如何通过 HTMLElement 对象的 style 属性获取内联样式: 这是一个段落内容. var pElem = document.getElementById('p1'); var style = pElem.style; console.log(style); 上述示例代码，通过 style 属性会得到 CSSStyleDeclaration 对象，该对象表示一个 CSS 属性键值对的集合。 CSSStyleDeclaration 对象 通过 element.style 返回的是 CSSStyleDeclaration 对象。CSSStyleDeclaration 对象表示一个CSS属性键值对的集合。 CSSStyleDeclaration 对象提供的属性和方法可以帮助我们获取 CSS 样式的具体内容。 属性或方法 描述 cssText 声明块的文本内容。 length 属性的数量。 item() 返回属性名。 例如: nameString= styleObj.item(0) Alternative: nameString= styleObj[0] getPropertyValue() 返回属性值。例如: valString= styleObj.getPropertyValue('color') cssText 属性 通过 element.style.cssText 属性获取 CSS 声明块的文本内容。 我们可以通过以下示例代码，学习如何通过 cssText 属性获取 CSS 声明块的文本内容: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; var cssText = styleDeclar.cssText; console.log(cssText); 上述示例代码的输出结果如下: 值得注意的是: cssText 属性返回的是 CSS 声明块的文本内容，解析操作时会比较麻烦。 遍历 CSSStyleDeclaration 对象 由于 CSSStyleDeclaration 对象具有 length 属性，返回该对象的属性的数量。我们可以通过这一特性实现遍历 CSSStyleDeclaration 对象，从而得到所有属性名和相应的值。 我们可以通过以下示例代码，学习如何遍历 CSSStyleDeclaration 对象: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; for ( var i=0; i 上述示例代码的输出结果如下: 在上述示例代码中，我们利用 CSSStyleDeclaration 对象的 length 属性控制遍历过程。 在遍历过程中，我们先利用 CSSStyleDeclaration 对象的 item() 方法得到每一个 CSSStyleDeclaration 对象的属性名，再利用 CSSStyleDeclaration 对象的 getPropertyValue() 方法根据属性名得到相应的值。 item() 方法 通过 element.style.item(index) 获取 CSS 的样式属性名，这种方式也可以通过 element.style[index] 方式进行替换。换句话讲，这两种方式是等价的。 我们可以通过以下示例代码，学习对比这两种方式: for ( var i=0; i 上述示例代码的输出结果如下: getPropertyValue() 方法 通过 element.style.item.getPropertyValue() 获取 CSS 的样式属性值，这种方式也可以通过 element.style[propertyName] 方式进行替换。 我们可以通过以下示例代码，学习对比这两种方式: for ( var i=0; i 上述示例代码的输出结果如下: 属性链方式操作 由于通过 element.style 返回的是 CSSStyleDeclaration 对象，所以我们也可以通过 element.style.attrName 的方式获取具体的样式属性的值。 我们可以通过以下示例代码，学习这种获取方式: 这是一个段落内容. var pElem = document.getElementById('p1'); var style = pElem.style; console.log(style.color); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:43:06 "},"chapter5/get-outline-style.html":{"url":"chapter5/get-outline-style.html","title":"第二节 获取外联样式表","keywords":"","body":"回顾什么是外联样式 所谓外联样式，就是在 HTML 页面中内嵌样式表或者引入外部样式文件，再通过 CSS 选择器定位 HTML 页面元素，为其定义样式。 以下示例代码，就是定义外联样式表: 上述示例代码，通过 元素引入外部的样式表。 .button { background-color: orange; } 上述示例代码，通过 元素定义内嵌样式表。 Document 对象的 styleSheets 属性 Document 对象提供了 styleSheets 属性，该属性返回包含所有外联样式表（内嵌样式表和外联样式表）的集合对象。 var styleSheetList = document.styleSheets; 上述语法结构中，作为返回值的 styleSheetList 是一个由 styleSheet 对象组成的列表，每个 styleSheet 对象表示 HTML 页面中内嵌样式表或外联样式表。 我们可以通过打印该属性值进行测试: console.log(document.styleSheets); 上述示例代码输出的结果如下: StyleSheetList 对象 Document 对象的 styleSheets 属性返回的是一个 StyleSheetList 对象。该对象是一个类数组对象，可以通过 for 循环语句进行遍历，或者将其转换为数组。 值得注意的是: StyleSheetList 对象本身不能使用数组方法进行操作。 我们可以通过以下示例代码，测试研究 StyleSheetList 对象: var styleSheetList = document.styleSheets; for (var i=0; i 上述示例代码中，每次循环得到的是 StyleSheet 对象。 CSSStyleSheet 对象 CSSStyleSheet 对象表示一个 CSS 样式表（内嵌样式表或外联样式表）。CSSStyleSheet 实现了更为通用的 StyleSheet，也从其父级 StyleSheet 继承了属性和方法。 我们可以通过打印该对象进行测试: console.log(document.styleSheets[0]); 上述示例代码输出的结果如下: CSSRuleList 对象 CSSStyleSheet 对象的 cssRules 属性返回的是一个 CSSRuleList 对象。该对象是一个类数组对象，可以通过 for 循环语句进行遍历，或者将其转换为数组。 我们可以通过以下示例代码，测试研究 CSSRuleList 对象: var styleSheet = document.styleSheets[0]; var cssRuleList = styleSheet.cssRules; for(var i=0; i 上述示例代码中，每次循环得到是 CSSRule 对象。 CSSRule 对象 CSSRule 对象表示一个 CSS 规则。一个 CSS 样式表包含了一组 CSS 规则。 CSSRule 对象的常见属性： style：返回 CSSStyleDeclaration 对象 cssText：CSS 规则 selectorText：选择器 我们可以通过以下示例代码，测试研究 CSSRule 对象: console.log(document.styleSheets[1].cssRules[0]); 上述示例代码输出的结果如下: Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:43:32 "},"chapter5/get-class-attr.html":{"url":"chapter5/get-class-attr.html","title":"第三节 获取 class 属性","keywords":"","body":"类选择器设置 CSS 样式 通过 CSS 的类选择器为 HTML 页面中的元素定义 CSS 样式，是我们开发中比较常见的一种方式。 我们也可以通过 HTML 页面元素 class 属性获取其对应的 CSS 样式。 .button { background-color: orange; } Element 对象的 className 属性 Element 对象提供了 className 属性用于获取 HTML 页面中指定元素的 class 属性值。 值得注意的是: Element 对象提供的是 className 属性，并不是 class 属性。原因是 class 在 JavaScript 中是关键字。 className 属性的的语法结构如下: var cName = elementNodeReference.className; 上述语法结构中，className 属性返回值 cName 表示一个字符串变量。表示当前元素的class属性的值，可以是由空格分隔的多个class属性值。 我们可以通过以下示例代码，学习 className 属性的使用: var btn = document.getElementById('btn'); console.log(btn.className); 上述示例代码输出的结果如下: Element 对象的 classList 属性 Element 对象的 className 属性虽然可以获取 HTML 页面中指定元素的 class 属性值，但返回值的是字符串类型。如果 HTML 页面中指定元素的 class 属性值为多个样式的话，对于我们操作会比较麻烦。 Element 对象还提供了 classList 属性，该属性可以获取 HTML 页面指定元素的 class 属性值的列表。其语法结构如下: var elementClasses = elementNodeReference.classList; 上述语法结构中，classList 属性返回值 elementClasses 表示HTML 页面元素的 class 属性值所组成的列表。 我们可以通过以下示例代码，学习 classList 属性的使用: var btn = document.getElementById('btn'); var elemClasses = btn.classList; for(var i=0; i 上述示例代码输出的结果如下: 浏览器兼容问题 Element 对象的 classList 属性，在 IE 8 及之前版本的浏览器中并不支持。所以，我们要想在各个浏览器中都支持该属性。 需要在 HTML 页面中引入以下 JavaScript 文件: /* * classList.js: Cross-browser full element.classList implementation. * 1.1.20170427 * * By Eli Grey, http://eligrey.com * License: Dedicated to the public domain. * See https://github.com/eligrey/classList.js/blob/master/LICENSE.md */ /*global self, document, DOMException */ /*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */ if (\"document\" in self) { // Full polyfill for browsers with no classList support // Including IE 该文件的下载地址为: https://github.com/eligrey/classList.js/blob/master/classList.js Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:42:21 "},"chapter5/get-computed-style.html":{"url":"chapter5/get-computed-style.html","title":"第四节 获取当前有效样式","keywords":"","body":"CSS 样式的优先级别 为 HTML 页面中的元素通过多种方式定义 CSS 样式。这些定义 CSS 样式方式的优先级别各不相同： 内联样式的优先级别最高 ID 选择器和伪类 类选择器和属性选择器 元素选择器和伪元素 通配符选择器和组合选择器 !important 将当前选择器的优先级别设置为最高 通过 DOM 操作 HTML 页面中指定元素的样式时，只需要获取其运行时的有效样式即可。 getComputedStyle() 方法 Window 对象中提供了 getComputedStyle() 方法，用于获取指定元素的当前有效样式，得到 CSSStyleDeclaration 对象。 其语法结构如下: var style = window.getComputedStyle(element, [pseudoElt]); 上述语法结构中，向 getComputedStyle() 方法传递的 element 参数表示获取有效样式的指定元素。而 pseudoElt 参数是个可选项，指定一个要匹配的伪元素的字符串。 值得注意的是: pseudoElt 参数必须对普通元素省略（或 null）。 getComputedStyle() 方法的返回值是 CSSStyleDeclaration 对象，表示指定元素的有效样式。 我们可以通过以下示例代码，学习 getComputedStyle() 方法的使用方式: var btn = document.getElementById('btn'); var style = window.getComputedStyle(btn, null); console.log(style.backgroundColor); currentStyle 属性 由于 getComputedStyle() 方法在 IE 8 及之前版本的浏览器中并不支持。所以，如果想要在 IE 8 及之前版本的浏览器中实现相同功能的话，需要使用 currentStyle 属性。 var btn = document.getElementById('btn'); var style = btn.currentStyle; console.log(style.backgroundColor); 通过 element.currentStyle 属性得到 currentStyle 对象，该对象提供了有关 CSS 样式表的所有样式属性。 浏览器兼容问题解决方案 在实际开发中，我们需要既支持 IE 8 及之前版本的浏览器，也需要支持其他浏览器。所以，我们可以编写如下代码，解决浏览器的兼容问题: function getStyle(elem, attrName){ // 判断 window.getComputedStyle() 方法是否存在 if (window.getComputedStyle){ return getComputedStyle(elem, null); }else{ return elem.currentStyle[attrName]; } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:27:30 "},"chapter5/set-inline-style.html":{"url":"chapter5/set-inline-style.html","title":"第五节 设置内联样式","keywords":"","body":"设置内联样式与获取类似，都是通过 style 属性或 setAttribute() 方法实现。 style 属性方式 设置内联样式，依旧是通过 HTML 页面元素的 style 属性实现。 具体语法结构如下: element.style = style; 我们可以通过以下示例代码，学习如何通过 style 属性设置内联样式: 这是一个段落内容. var pElem = document.getElementById('p1'); pElem.style = 'color: lightblue;font-weight: lighter'; 值得注意的是: 这种方式定义 CSS 样式，是字符串类型。并不适用于定义过多的 CSS 样式属性。 setAttirbute() 方法方式 通过 style 属性设置内联样式，我们还可以调用 element.setAttribute() 方法实现。 这是一个段落内容. var pElem = document.getElementById('p1'); // 通过 element.setAttribute() 方法设置样式 pElem.setAttribute('style','color: lightblue;font-weight: lighter'); // 通过 element.removeAttribute() 方法删除样式 pElem.removeAttribute('style'); 值得注意的是: 通过 setAttribute() 方法设置内联样式同样是字符串类型。 CSSStyleDeclaration 对象 通过 style 属性获取内联样式的学习，我们知道 style 属性返回的是 CSSStyleDeclaration 对象。该对象封装了 CSS 中的所有样式属性，所以我们也可以通过该对象设置内联样式。 CSSStyleDeclaration 对象提供的属性和方法可以帮助我们设置 CSS 样式的具体内容。 属性或方法 描述 setProperty() 为指定的 CSS 样式属性设置一个新的值。 removeProperty() 删除指定的 CSS 样式属性。 setProperty() 方法 CSSStyleDeclaration 对象提供的 setProperty() 方法，用于设置指定的 CSS 样式属性。其语法结构如下: style.setProperty(propertyName, value, priority); 上述语法结构中，作为参数的 propertyName 表示要修改的 CSS 样式属性名称。 value 是可选的，表示为修改的 CSS 样式属性新的值。如果没有设置任何值，则表示空字符串。 参数 priority 也是可选的，表示设置 CSS 样式的优先级别。 我们可以通过以下示例代码，学习如何通过 setProperty() 方法设置 CSS 的样式属性: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; styleDeclar.setProperty('color','lightblue'); removeProperty() 方法 CSSStyleDeclaration 对象提供的 removeProperty() 方法，用于删除指定的 CSS 样式属性。其语法结构如下: var oldValue = style.removeProperty(property); 上述语法结构中，作为参数的 property 表示要删除的 CSS 样式属性名称，作为返回值的 oldValue 表示删除的样式属性的值。 我们可以通过以下示例代码，学习如何通过 removeProperty() 方法删除 CSS 的样式属性: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; styleDeclar.removeProperty('font-weight'); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:27:54 "},"chapter5/set-class-attr.html":{"url":"chapter5/set-class-attr.html","title":"第六节 设置 class 属性","keywords":"","body":"设置 class 属性与获取 class 属性方式类似，都是通过 Element 对象提供的 className 属性和 classList 属性实现。 Element 对象的 className 属性 Element 对象提供的 className 属性既可以实现获取，也可以实现设置。其设置的语法结构如下: elementNodeReference.className = cName; 上述语法结构中，作为值的 cName 是一个字符串变量。表示当前元素的class属性的值，可以是由空格分隔的多个class属性值。 我们可以通过以下示例代码，学习如何通过 className 属性设置: var btn = document.getElementById('btn'); var className = btn.className; className += ' animate'; btn.className = className; Element 对象的 classList 属性 Element 对象提供的 classList 属性与 className 属性类似，既可以实现获取，也可以实现设置。 但 classList 属性自身是只读属性，换句话讲，我们并不能通过 classList 属性进行设置。而是通过以下方法实现: 方法名称 描述 add() 添加指定的类值。如果这些类已经存在于元素的属性中，那么它们将被忽略。 remove() 删除指定的类值。 item() 按集合中的索引返回类值。 toggle() 切换指定的类值。 contains() 检查元素的类属性中是否存在指定的类值。 我们可以通过以下示例代码，学习上述方法的使用: var btn = document.getElementById('btn'); var classList = btn.classList; // 添加 .animate 样式 classList.add('animate'); // 删除 .animate 样式 classList.remove('animate'); // 如果 .animate 存在，则删除；如果 .animate 不存在，则添加 classList.toggle('animate'); // 判断是否存在 .animate 样式 console.log(classList.contains('animate')); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:28:13 "},"chapter5/element-style-attr.html":{"url":"chapter5/element-style-attr.html","title":"第七节 Element 对象的样式属性","keywords":"","body":"Element 对象提供一系列有关样式的属性: clientHeight 和 clientWidth 属性 scrollHeight 和 scrollWidth 属性 scrollTop 和 scrollLeft 属性 继承于 Element 对象的 HTMLElement 对象同样提供一系列有关样式的属性: offsetParent 属性 offsetHeight 和 offsetWidth 属性 offsetTop 和 offsetLeft 属性 元素内部的宽度和高度 Element 对象的 clientWidth 和 clientHeight 属性表示元素内部的宽度和高度，单位为像素。这些属性的值包含内边距，但不包含滚动条、边框和外边距。 我们也可以通过以下方式计算 clientWidth 和 clientHeight 属性: clientWidth = CSS 的 width + CSS 的 padding – 滚动条的宽度（如果存在的话） clientHeight = CSS 的 height + CSS 的 padding – 滚动条的高度（如果存在的话） 我们可以通过以下示例代码，学习测试 clientWidth 和 clientHeight 属性: var div = document.getElementById('d'); // 获取 div 的样式 var style = document.styleSheets[0].cssRules[0].style; // 计算 clientWidth 属性的值 var clientWidth = parseInt(style.width) + parseInt(style.paddingLeft) + parseInt(style.paddingRight); // 测试打印 clientWidth = width + padding-left + padding-right console.log(div.clientWidth, clientWidth); 内容区的宽度和高度 Element 对象的 scrollWidth 属性表示元素内容的宽度，单位为像素。 scrollWidth 属性返回元素内容区的宽度和元素本身宽度中更大的那个值。 Element 对象的 scrollHeight 属性表示元素内容的高度，单位为像素。scrollHeight 属性包含 overflow 样式属性导致不可见的内容区。 我们可以通过以下示例代码，学习测试 scrollWidth 和 scrollHeight 属性: var div1 = document.getElementById('d1'); console.log(div1.scrollWidth); var div2 = document.getElementById('d2'); console.log(div2.scrollHeight); 滚动条滚动的宽度和高度 Element 对象的 scrollLeft 属性表示滚动条到元素左边的距离，单位为像素。scrollLeft 属性的默认值为 0。 Element 对象的 scrollTop 属性表示滚动条到元素顶部的距离，单位为像素。scrollHeight 属性的默认值为 0。 判断元素内容是否滚动到底 如果元素内容滚动到底的话，如下等式返回的结果为 true，否则返回为 false: element.scrollHeight - element.scrollTop === element.clientHeight 获取指定元素的定位父元素 Element 对象提供的 offsetParent 属性用于返回一个指向最近的包含该元素的定位元素。其语法结构如下: var parentObj = element.offsetParent; 上述语法结构中，作为返回值的 parentObj 表示一个指向最近的包含该元素的定位元素。 值得注意的是: 如果祖先元素中没有开始定位，则 offsetParent 为 body 元素。 我们可以通过以下示例代码，学习 offsetParent 属性的使用: #parent { position: relative; } var btn = document.getElementById('btn'); console.log(btn.offsetParent); offsetParent 属性的浏览器兼容性 在不同浏览器中，对 offsetParent 属性的支持情况也有所不同: 在 Webkit 中，如果元素为隐藏的（该元素或其祖先元素的 style.display 为 \"none\"），或者该元素的 style.position被设为 \"fixed\"，则该属性返回 null。 在 IE 9 中，如果该元素的 style.position 被设置为 \"fixed\"，则该属性返回 null。（display:none 无影响。） 获取指定元素的定位相关属性 与开启定位相关的属性还有以下几种: 指定元素的 offsetWidth 和 offsetHeight 属性分别表示该元素的布局宽度和布局高度，其中包含边框、内边距、滚动条和 CSS 设置的宽度或高度的值。 指定元素的 offsetLeft 和 offsetTop 属性分别表示该元素距离定位父元素左边界和上边界的距离。 值得注意的是: offsetWidth、offsetHeight、offsetLeft 和 offsetTop 属性的值都是整数。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:41:53 "},"chapter6/what-is-event.html":{"url":"chapter6/what-is-event.html","title":"第六章 事件","keywords":"","body":"所谓事件，就是浏览器告知 JavaScript 程序用户的行为。例如用户点击了 HTML 页面中的某个按钮，或者用户输入用户名或密码等操作。 如下示例代码，演示了如何通过事件完成用户点击按钮后的逻辑: 按钮 var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } 根据上述示例代码，具体执行流程如下: 事件类型 事件根据使用的场景不同，可以分为如下几种: 依赖于设备的输入事件：键盘事件和鼠标事件，这些事件都是直接和设备相关的。 独立于设备的输入事件：例如 click 事件等，这些事件并没有直接与设备相关。 用户界面的相关事件：用户界面事件属于较高级的事件，一般多用于表单中的组件。 状态变化的相关事件：这些事件与用户行为无关，而是由网络或浏览器触发的。 特定 API 事件：这些事件多用于特定场景的实现，例如 HTML5 中提供的拖放 API 中的事件等。 与错误处理的相关事件 键盘事件 键盘事件，主要是指当用户操作电脑键盘时所触发的事件。主要的键盘事件如下: 事件名称 描述 keydown 用户按下一个按键。 keypress 用户按下并释放一个按键。如果该按键不是修饰键时，触发该事件。 keyup 用户释放一个按键。 值得注意的是: 如果是切换指示灯的状态，如Caps Lock键，Num Lock键和Scroll Lock键。这些按键仅发送 keydown 事件和 keyup 事件。 鼠标事件 鼠标事件，主要是指当用户操作电脑鼠标时所触发的事件。主要的鼠标事件如下: 事件名称 描述 mousedown 用户按下鼠标按键。 mouseup 用户释放鼠标按钮。 mouseover 用户移动鼠标到指定元素上。 mousemove 用户鼠标移动。 mouseout 用户将鼠标从指定元素上移除。 独立于设备的输入事件 独立于设备的事件，主要是指当这些事件没有与指定设备相关联。具有如下几种: 事件名称 描述 click 用户点击一下。 dblclick 用户连续点击两下。 contextmenu 用户点击鼠标右键打开上下文菜单。 状态变化的相关事件 状态变化的相关事件，主要是指网络或浏览器的状态发生改变。具有如下几种: 事件名称 描述 load 表示 HTML 页面或图片加载完毕。 unload 表示离开或关闭 HTML 页面。 resize 表示浏览器窗口被重新调整的大小。 scroll 表示 HTML 页面滚动。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:46:00 "},"chapter6/regist-event.html":{"url":"chapter6/regist-event.html","title":"第二节 注册事件","keywords":"","body":"所谓注册事件，就是将 JavaScript 函数与指定的事件相关联，被绑定的函数成为该事件的句柄。当该事件被触发时，绑定的函数会被调用。 注册事件具有以下三种方式实现: HTML 页面元素提供的事件属性 DOM 标准规范中 HTML 相关对象提供的事件属性 通过向 HTML 页面中指定元素添加事件监听器 HTML 元素的事件属性 HTML 页面的元素提供了一系列的标准事件属性，通过这些事件属性可以实现注册事件的功能。 例如以下代码示例，演示了如何通过 HTML 元素的事件属性完成注册事件: 按钮 function clickBtn(){ console.log('你终于点中了我...'); } 值得注意的是: 这种方式并没有将 HTML 结构与行为有效地分离。 DOM 对象的事件属性 通过 DOM 标准规范中的 Document 对象定位 HTML 页面的元素，所返回的 DOM 对象提供了一系列的事件属性，通过这些事件属性可以实现注册事件的功能。 例如以下代码示例，演示了如何通过 DOM 对象的事件属性完成注册事件: 按钮 var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } 通过 DOM 对象的事件属性方式注册事件，是不允许重复注册的。如果以这种方式为某个元素注册相同事件多次的话，只有最后一次注册的函数有效。 例如以下代码示例: var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } btn.onclick = function(){ console.log('你又点中了我...'); } 事件监听器 DOM 标准规范提供的 addEventListener() 方法，调用该方法表示向指定元素添加事件监听器。 addEventListener() 方法的语法格式如下: element.addEventListener(eventName, functionName, capture) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 为元素指定具体的事件名称（例如单击事件是 click 等） functionName 注册事件的句柄 capture 设置事件是捕获阶段还是冒泡阶段。false 为默认值，表示冒泡阶段 如下示例代码，是 DOM 对象的事件属性的实现方式: 按钮 var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } 使用 addEventListener() 方法可以将上述代码进行改写: 按钮 var btn = document.getElementById('btn'); btn.addEventListener('click',function(){ console.log('你终于点中了我...'); }); 事件监听器的优点 addEventListener() 方法是 DOM 的标准规范所提供的注册事件监听器的方法，它的优点包括以下几点: 它允许某个 HTML 页面的元素在绑定一个事件的同时，注册多个事件的句柄（事件处理函数）。 它提供了一种更精细的手段控制事件的触发阶段（是捕获阶段还是冒泡阶段）。 IE 8及之前版本浏览器的事件监听器 在 IE 8 及之前版本的浏览器，并不支持 addEventListenter() 方法添加事件监听器。而是使用 attachEvent() 方法进行添加。 attachEvent() 方法的语法格式如下: element.attachEvent(eventName, functionName) 参数名称 描述 eventName 为元素指定具体的事件名称（例如单击事件是 click 等） functionName 注册事件的句柄 我们可以通过以下示例代码，学习如何使用 attachEvent() 方法: 按钮 \u000b var btn = document.getElementById('btn'); btn.attachEvent('onclick',function(){ console.log('你终于点中了我...'); }); 监听器的浏览器兼容方案 在实际开发中，我们既要兼容 IE 8及之前版本的浏览器，也要兼容其他浏览器。所以，我们可以自定义事件注册方法实现: function bind(elem, event, callback){ // 判断是否存在 addEventListener if (elem.addEventListener){ elem.addEventListener(event, callback, false); }else{ elem.attachEvent('on' + event, callback); } } 事件监听器中的 this 当使用 addEventListener() 方法为某个 HTML 页面元素注册事件的时候，this 就指代注册事件的元素。 例如以下示例代码: btn.addEventListener('click',function(){ console.log(btn.textContent); }); 上述代码可以使用 this 改写如下方式: btn.addEventListener('click',function(){ console.log(this.textContent); }); 当使用 attachEvent() 方法为某个 HTML 页面元素注册事件的时候，this 指代的是 window 对象，而不是注册事件的元素。 例如以下示例代码: var btn = document.getElementById('btn'); btn.attachEvent('onclick',function(){ console.log(this); }); 上述代码输出的结果如下: [Object window] 监听器的浏览器兼容优化方案 由于 addEventListener() 方法中的 this 与 attachEvent() 方法中的 this 的含义不同，我们需要将监听器的浏览器兼容方案进行优化: function bind(elem, event, callback){ // 判断是否存在 addEventListener if (elem.addEventListener){ elem.addEventListener(event, callback, false); }else{ elem.attachEvent('on' + event, function(){ // 将 this 的指向修改为注册事件的元素 callback.call(elem); }); } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:30:22 "},"chapter6/remove-regist-event.html":{"url":"chapter6/remove-regist-event.html","title":"第三节 移除注册事件","keywords":"","body":"事件监听器的内存问题 我们先来看一个示例代码: var els = document.getElementsByTagName('*'); for(var i=0 ; i 上述示例代码中，每次循环都会创建一个新的匿名函数。这样的结果会导致占用的存储空间很大。 我们再来看一个示例代码: var els = document.getElementsByTagName('*'); function processEvent(e){ /*do something*/ } for(var i=0 ; i 上述示例代码中，每次循环使用之前定义的函数。这样的结果是占用的存储空间更小。 移除注册事件 在上述两段示例代码中，除了占用存储空间大小的区别以外，第一个示例代码由于使用了匿名函数，是无法调用 removeEventListener() 方法移除注册的事件的。相反，第二个示例代码是允许的。 removeEventListener() 方法的语法格式如下: element.removeEventListener(eventName, functionName, capture) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 表示移除的事件名称（例如单击事件是 click 等） functionName 移除注册事件的句柄（之前使用 addEventListener() 方法定义的） capture 设置事件是捕获阶段还是冒泡阶段。false 为默认值，表示冒泡阶段 我们可以通过以下示例代码，学习如何使用 removeEventListener() 方法: 按钮 var btn = document.getElementById('btn'); function listener(){ console.log('你终于点中了我...'); } btn.addEventListener('click',listener); btn.removeEventListener('click',listener); detachEvent() 方法 移除注册事件在 IE 8 及之前版本的浏览器都不支持 removeEventListener() 方法，而是单独提供了 detachEvent() 方法。其语法结构如下: element.detachEvent(eventName, functionName) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 表示移除的事件名称（例如单击事件是 click 等） functionName 移除注册事件的句柄（之前使用 attachEvent() 方法定义的） 我们可以通过以下示例代码，学习如何使用 detachEvent() 方法: 按钮 var btn = document.getElementById('btn'); function listener(){ console.log('你终于点中了我...'); } btn.attachEvent('click',listener); btn.detachEvent('click',listener); 移除注册事件的浏览器兼容解决方案 与注册事件相似，移除注册事件在实际开发中，同样需要兼容各大浏览器，具体解决方案如下: function unbind(elem, eventName, functionName){ if (elem.removeEventListener){ elem.removeEventListener(eventName, functionName); } else { elem.detachEvent('on'+eventName, functionName); } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:30:49 "},"chapter6/event-object.html":{"url":"chapter6/event-object.html","title":"第四节 Event 事件对象","keywords":"","body":"什么是事件对象 为 HTML 页面中的元素注册事件时，事件的处理函数具体一个参数，该参数就是 Event 事件对象。 Event 事件对象中包含了该事件的信息，以及该事件发生在哪个元素上。 element.addEventListener(eventName, function(event){ // event 就是事件对象 }, capture) 值得注意的是: 当事件发生时， Event 事件对象会被创建并依次传递给事件监听器。 由于 Event 事件对象是事件处理函数的参数，所以参数名允许自定义的。 Event 事件对象的属性或方法 属性或方法 描述 target 表示触发当前事件的 HTML 元素 currentTarget 表示注册当前事件的 HTML 元素 srcElement IE 8 及之前版本浏览器支持，表示触发当前事件的 HTML 元素 returnValue IE 8 及之前版本浏览器支持，表示取消当前事件的默认行为 cancelBubble IE 8 及之前版本浏览器支持，表示阻止当前事件的冒泡行为 preventDefault() 表示取消当前事件的默认行为 stopPropagation() 表示阻止当前事件的冒泡行为 IE 8及之前版本浏览器的 Event 事件对象 IE 8 及之前版本浏览器，HTML 页面元素注册事件时，Event 事件对象并不是作为事件的处理函数的参数，而是作为 window 对象的属性存在的。 我们可以通过以下示例代码进行测试: 按钮 var btn = document.getElementById('btn'); btn.attachEvent('onclick',function(){ console.log(window.event); }); Event 事件对象的兼容解决方案 如果 HTML 页面元素注册事件是通过 HTML 页面元素的事件属性或者 DOM 提供的事件属性方式实现的话，Event 事件对象的兼容解决方案如下代码示例: event = event || window.event; 或者，也可以通过如下代码示例解决: if (!event){ event = window.event; } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:31:10 "},"chapter6/get-target-element.html":{"url":"chapter6/get-target-element.html","title":"第五节 获取目标元素","keywords":"","body":"Event 事件对象的 target 属性 Event 事件对象提供了 target 属性，用于获取触发当前事件的 HTML 元素。 链接 var li = document.getElementById('li'); li.addEventListener('click',function(event){ console.log(event.target) }); 上述示例代码运行效果如右图所示: 如果点击 元素，则 元素触发事件，target 属性表示 元素。 链接 如果点击 元素，则 元素触发事件，target 属性表示 元素。 链接 如果点击 元素，则 元素触发事件，target 属性表示 元素。 链接 target 属性的浏览器的兼容性 IE 8 及之前版本浏览器并不支持 target 属性，而是提供了与 target 属性作用相同的 srcElement 属性。 链接 var li = document.getElementById('li'); li.attachEvent('onclick',function(event){ event = event || window.event; console.log(event.srcElement) }); Event 事件对象的 currentTarget 属性 Event 事件对象提供了 currentTarget 属性，用于获取注册当前事件的 HTML 元素。 链接 var li = document.getElementById('li'); li.addEventListener('click',function(event){ console.log(event.currentTarget) }); 上述示例代码，无论点击 、 或者 元素，currentTarget 属性得到都是注册事件的 元素。 事件处理函数中的 this 事件处理函数中的 this，作用与事件对象的 currentTarget 属性相同，可以获取注册当前事件的 HTML 元素。 链接 var li = document.getElementById('li'); li.addEventListener('click',function(event){ console.log(this) }); currentTarget 属性的浏览器兼容性 IE 8 及之前版本的浏览器并不支持 Event 事件对象的 currentTarget 属性，并且也没有提供相应的属性或方法。监听器 attachEvent() 方法中的 this 表示 window 对象，也不是注册事件的 HTML 元素。 function bind(elem, event, callback){ if (elem.addEventListener){ elem.addEventListener(event, callback, false); }else{ elem.attachEvent('on' + event, function(){ callback.call(elem); }); } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:45:14 "},"chapter6/prevent-default.html":{"url":"chapter6/prevent-default.html","title":"第六节 阻止默认行为","keywords":"","body":"什么是默认行为 所谓默认行为，就是指 HTML 元素不借助 JavaScript 逻辑原本具有的动态效果。例如以下 HTML 元素: 元素的跳转功能 元素中点击 提交按钮时，提交表单功能 输入框的输入文本内容功能 单选框或复选框的切换选项功能 Event 事件对象的 preventDefault() 方法 Event 事件对象提供了 preventDefault() 方法，用于阻止 HTML 元素的默认行为。 链接 var a = document.getElementById('a'); a.onclick = function(event){ event.preventDefault(); } 浏览器的兼容性 IE 8 及之前版本的浏览器，并不支持 preventDefault() 方法，而是提供了 returnValue 属性实现相同功能。 链接 var a = document.getElementById('a'); a.onclick = function(event){ if (event.preventDefault){ event.preventDefault(); }else{ event.returnValue = false; } } return false 语句 事件的处理函数中，我们也可以使用 return false 语句阻止默认行为。 return false 语句除了具有阻止默认行为功能之外，编写在 return false 语句后面的 JavaScript 代码并不会被执行。 值得注意的是: return false 语句只有在 DOM 规范标准的事件属性有效，而在事件监听器的处理函数中是无效的。 var a = document.getElementById('a'); a.onclick = function(event){ return false; } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:32:58 "},"chapter6/get-mouse-ordinate.html":{"url":"chapter6/get-mouse-ordinate.html","title":"第七节 获取鼠标坐标","keywords":"","body":"Event 事件对象提供了触发注册事件时，有关鼠标的坐标值相关属性: pageX 和 pageY: 表示鼠标在整个页面中的位置。如果页面过大（存在滚动条），部分页面可能存在可视区域之外。 clientX 和 clientY: 表示鼠标在整个可视区域中的位置。 screenX 和 screenY: 表示鼠标在整个屏幕中的位置。从屏幕（不是浏览器）的左上角开始计算。 offsetX 和 offsetY: 表示鼠标相对于定位父元素的位置。 鼠标相对页面的坐标 pageX 和 pageY 属性表示鼠标相对于页面的坐标值，我们可以通过以下示意图更好地理解: 值得注意的是: 部分页面可能会在浏览器可视窗口的外面。如果部分页面存在可视窗口外面的话，相对于页面的坐标值会大于相对于可视窗口的坐标值。 鼠标相对可视窗口的坐标 clientX 和 clientY 属性表示相对于可视窗口的坐标值，我们可以通过以下示意图更好地理解: 值得注意的是: clientX 和 clientY 表示鼠标相对于浏览器可视窗口的坐标，是不包含浏览器的地址栏、工具栏等区域的。 鼠标相对屏幕的坐标 screenX 和 screenY 属性表示相对于电脑屏幕的坐标值，我们可以通过以下示意图更好地理解: 鼠标相对目标元素的坐标 offsetX 和 offsetY 属性表示相对于目标元素的坐标值，我们可以通过以下示意图更好地理解: offsetX 和 offsetY 表示鼠标相对于目标元素的偏移量。这里的目标元素指的是触发注册事件的元素。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:44:56 "},"chapter6/event-flow.html":{"url":"chapter6/event-flow.html","title":"第八节 事件流","keywords":"","body":"什么是事件流 所谓事件流，就是当触发某个元素的事件时，事件会按照 DOM 树结构进行传播，传播的过程分为捕获阶段、目标阶段和冒泡阶段三个阶段。 捕获阶段：该阶段是由网景公司提出的。按照 DOM 树结构由 document 对象向下的顺序传播，直到目标元素为止。 目标阶段：该阶段就是指目标元素触发当前事件。 冒泡阶段：该阶段是由微软公司提出的，按照 DOM 树结构由目标元素向上的顺序传播，直到 document 对象为止。 事件监听器 事件监听器 addEventListener() 方法的第三个参数的作用，就是设置当前注册的事件是捕获阶段还是冒泡阶段。 element.addEventListener(eventName, functionName, capture) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 为元素指定具体的事件名称（例如单击事件是 click 等） functionName 注册事件的句柄 capture 设置事件是捕获阶段还是冒泡阶段。false 为默认值，表示冒泡阶段 捕获阶段 如果将事件监听器方法 addEventListener() 的第三个参数的只设置为 true，即为捕获阶段。 如下代码示例，使用事件监听器方法同时为三个 元素注册相同事件: 值得注意的是: IE 8 及之前版本的浏览器不支持捕获阶段。 我们可以通过以下示意图更好地理解事件的捕获阶段: 冒泡阶段 如果将事件监听器方法 addEventListener() 的第三个参数的只设置为 false，即为冒泡阶段。 如下代码示例，使用事件监听器方法同时为三个 元素注册相同事件: 我们可以通过以下示意图更好地理解事件的冒泡阶段: 取消事件冒泡 当元素注册事件设置为冒泡阶段时，可以通过 Event 事件对象的 stopPropagation() 方法取消事件冒泡。 var d1 = document.getElementById('d1'); d1.addEventListener('click',function(){ alert(this.id); },false); var d2 = document.getElementById('d2'); d2.addEventListener('click',function(){ alert(this.id); },false); var d3 = document.getElementById('d3'); d3.addEventListener('click',function(event){ alert(this.id); event = event || window.event; event.stopPropagation(); },false); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:44:20 "},"chapter6/event-delegate.html":{"url":"chapter6/event-delegate.html","title":"第九节 事件委托","keywords":"","body":"什么是事件委托 当为大量的 HTML 元素注册相同事件，并且事件的句柄逻辑完全相同时，会造成页面速度下降。不过，事件流允许在这些 HTML 元素的共同父级元素注册事件。这种方式被称为事件委托。 按钮 按钮 按钮 var btn = document.getElementById('parent'); btn.addEventListener('click', function(event){ if (event.target.nodeName === 'BUTTON'){ alert('我是一个链接.') } }); 事件委托的优势 适用于新创建的元素 如果向 DOM 树结构中添加新的元素，那么不需要再向这个新元素注册相同事件。因为注册事件已经委托给了该元素的祖先元素完成。 简化逻辑代码 这种方式只需要祖先元素一次注册事件，而不需要分别为大量元素注册事件。使得逻辑代码的性能提高，也更加容易维护。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:34:53 "},"chapter7/get-form-element.html":{"url":"chapter7/get-form-element.html","title":"第七章 表单操作","keywords":"","body":"获取表单元素 获取表单元素的方式，大体可以分为以下几种方式: Document 对象提供的定位页面元素的一系列方法 Document 对象提供了 forms 属性 Document 对象通过表单的 name 属性值获取指定表单元素 接下来，我们将分别介绍这几种方式的使用。 定位页面元素的方法 Document 对象提供了如下几种定位页面元素的方法: getElementById() 方法 getElementsByName() 方法 getElementsByTagName() 方法 getElementsByClassName() 方法 querySelector() 方法 querySelectorAll() 方法 以上几种方法的具体使用，请参考第二章节的《定位页面元素》一节内容。 上述几种方法的使用，我们可以通过如下示例代码进行学习: var formId = document.getElementById('myform'); var formName = document.getElementsByName('myform'); var formElement = document.getElementsByTagName('form')[0]; var formClass = document.getElementsByClassName('login')[0]; var formId2 = document.querySelector('#myform'); var formElement2 = document.querySelectorAll('form')[0]; Document 对象的 forms 属性 Document 对象提供了 forms 属性，用于获取当前 HTML 页面中所有表单的集合。例如如下示例代码: var forms = document.forms; 该属性返回 HTMLCollection 对象，该对象封装了当前 HTML 页面中的所有表单对象。例如如下示例代码: var forms = document.forms; console.log(forms); 上述示例代码打印了通过 document.forms 得到的结果，结果如下图所示: 我们知道 HTMLCollection 对象是一个类数组对象，所以可以通过索引值的方式得到我们想要的表单。例如如下示例代码: var forms = document.forms; console.log(forms[0]); 上述示例代码得到了 HTMLCollection 集合中的第一个表单对象，结果如下图所示: 如果在定义表单元素时，定义了 name 属性的话，我们还可以通过表单元素的 name 属性得到我们想要的表单。例如如下示例代码: var forms = document.forms; console.log(forms['myform']); 说明: 上述示例代码中的 \"myform\" 表示表单的 name 属性值。 上述示例代码同样得到了 HTMLCollection 集合中的第一个表单对象，结果如下图所示: 表单的 name 属性值方式 较早的浏览器还会将定义了 name 属性的表单保存在 document 对象中。这样，我们就可以通过如下方式来访问指定的表单: document.表单名 我们可以通过如下示例代码进行学习: var form = document.myform; console.log(form); 上述示例代码也可以得到我们想要的表单元素。 注意: 这种方式并不推荐，因为在新版本的浏览器中可能不再支持。 获取表单组件 获取表单组件的方式，大体可以分为以下几种方式: Document 对象提供的定位页面元素的一系列方法 HTMLFormElement 对象的 elements 属性 接下来，我们将分别介绍这几种方式的使用。 定位页面元素的方法 Document 对象提供了如下几种定位页面元素的方法: getElementById() 方法 getElementsByName() 方法 getElementsByTagName() 方法 getElementsByClassName() 方法 querySelector() 方法 querySelectorAll() 方法 以上几种方法的具体使用，请参考第二章节的《定位页面元素》一节内容。 上述几种方法的使用，我们可以通过如下示例代码进行学习: 用户名: 密码: 爱好: html css javascript var username = document.getElementById('username'); var loves = document.getElementsByName('love'); HTMLFormElement 对象的 elements 属性 HTMLFormElement 对象提供了 elements 属性，用于获取指定表单的所有组件的集合。例如如下示例代码: 用户名: 密码: 爱好: html css javascript var myform = document.forms[0]; var formElements = myform.elements; console.log(formElements); 该属性返回 HTMLFormControlsCollection 对象（如果是 HTML4 的话: 则是 HTMLCollection 对象）。 上述示例代码的输出结果，如下图所示: 注意: HTMLFormElement 对象提供了 elements 属性获取的表单组件中，不包含 type 为 image 的 input 元素。 例如如下示例代码: var myform = document.forms[1]; var formElements = myform.elements; console.log(formElements); 上述示例代码输出的结果，如下图所示: 上述结果表示 HTMLFormElement 对象的 elements 属性得到的集合中，并没有得到 type 为 image 的 input 元素。 表单序列化 表单序列化是在 Ajax 出现之后流行起来的。原因也很简单，因为 Ajax 等异步提交技术无法使用表单默认的提交行为。如果每个表单组件一一获取又比较麻烦，所以才出现了表单序列化。 说明: 上述内容只是作者个人的理解。 什么是表单序列化 所谓的表单序列化，就是模拟表单元素默认的提交行为来获取表单组件的数据内容。所以，我们要想掌握表单序列化的话，必须要先了解表单在提交时是如何获取数据的。 接下来，我们通过一个小案例来了解表单在提交时时如何获取数据的: 用户名: 密码: 爱好: html css javascript 上述示例代码是一个普通的表单，其中包含了文本框、密码框和多选框。当然，需要具有一个提交按钮才可以。 我们运行这个 HTML 页面，在浏览器的地址栏中可以看到如下结果: http://localhost/example.html?username=longestory&password=longestory&love=html&love=javascript 上述结果中，\"?\"符号之后的内容就是表单提交之后，得到表单组件中的数据内容。 通过上述测试结果，我们可以总结出以下表单提交时获取表单组件的结论: 获取表单组件的 name 属性值和用户输入的数据，格式为 \"name=value\" 多个表单组件之间使用了 \"&\" 符号进行连接 只获取了被选中的多选框、单选框或下拉列表 实现表单序列化 根据上述的测试所得到的结论，我们就可以模拟表单在提交时获取表单组件的数据方式进行表单序列化。例如如下示例代码: function serialize(form) { // 参数验证 if(!form && form.nodeName.toUpperCase() != \"FORM\" ){ throw new Error(\"invalid parameters\"); } var encode = window.encodeURIComponent, slice = Array.prototype.slice; var params = [], i = 0, fields = slice.call(form.elements), len = fields.length, el, type; for(;i 注意: 以上代码在 IE8 会报错，原因是 option 元素的实现并非一个 JavaScript 对象，导致无法使用 slice。 上述示例代码就是自定义实现表单序列化的一个函数。当然，这种实现方式并不唯一。而且，目前很多第三方的 JS 库也实现了此功能。 说明: 上述实现表单序列化的代码来源于 zhangguixu的博文 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 13:41:30 "},"chapter7/form-module.html":{"url":"chapter7/form-module.html","title":"第二节 表单操作","keywords":"","body":"表单元素的组件主要分为 、 和 这三种元素。但由于 元素的 type 属性值较多，实际情况要更复杂一些。 上述三种表单组件元素中， 和 元素都表示文本框， 表示下拉列表。所以，表单组件的操作主要可以分为以下两种: 文本框的操作: 主要是针对 和 两种元素 下拉列表的操作: 主要是针对 和 两种元素 文本框的操作 input 元素对应 DOM 中的对象是 HTMLInputElement 对象，而 textarea 元素对应 DOM 中的对象是 HTMLTextAreaElement 对象。 HTMLInputElement 对象和 HTMLTextAreaElement 对象的共同父级对象是 HTMLElement 对象。所以，这两个对象在很多操作上是比较相似的。当然，也有一些不同之处。 接下来，我们就针对这两个元素的操作，进行详细的学习。 文本内容的选择 HTMLInputElement 对象和 HTMLTextAreaElement 对象都提供了 select() 方法，该方法用于选择当前文本框的所有文本内容。 我们可以通过以下示例代码，学习 select() 方法的使用: var username = document.getElementById('username'); username.select(); 上述示例代码运行后的效果如下图所示: 说明: textarea 元素与 input 元素的效果类似，这里我们就不再提供示例代码了。 select() 方法多与文本框的获取焦点事件配合使用。效果就是当某个文本框获取焦点时，自动将文本框的默认提示内容全部选中。例如如下示例代码: var username = document.getElementById('username'); username.addEventListener('focus',function(){ username.select(); }); 上述示例代码的运行效果是: 当用户使用鼠标点击该文本框时，触发 focus 事件。同时将该文本框的文本内容全部选中。 1. select 事件 select() 方法对应着 select 事件。也就是说，当调用 select() 方法时，会触发 select 事件。 我们可以通过以下示例代码，对 select 事件进行学习: var username = document.getElementById('username'); username.addEventListener('focus',function(){ username.select(); }); username.addEventListener('select',function(){ console.log(\"this input element's select()\"); }); 上述示例代码的运行效果是: 当用户使用鼠标点击该文本框时，触发 focus 事件。同时将该文本框的文本内容全部选中，并触发 select 事件。如下图所示: 说明: 上述输出结果为两次，并非一次。原因是调用 select() 方法会触发一次 select 事件，选择指定文本框的文本内容也会再触发一次 select 事件。 选择指定文本框的文本内容时触发 select 事件，在不同浏览器中情况也不尽相同。具体如下: 如果是 IE9+、Chrome、Firefox、Opera 以及 Safari 浏览器中，必须在用户选择文本内容并释放鼠标时，才会触发 select 事件 如果是 IE8 及之前版本的浏览器，则是在用户选择文本内容时（没有释放鼠标）就触发了 select 事件。 2. 获取选择的文本内容 select 事件只是让我们知道用户在什么时候选择了指定文本框的文本内容，但并不能让我们知道用户选择了什么文本内容。 HTML5 新版本中通过新增两个属性来解决用户选择了什么文本内容的问题。 属性名 描述 selectionStart 选择文本内容的开始索引值 selectionEnd 选择文本内容的结束索引值 我们可以通过如下示例代码方式，得到用户选择的文本内容: var username = document.getElementById('username'); username.addEventListener('select',function(){ var textValue = username.value; var result = textValue.substring(username.selectionStart, username.selectionEnd); console.log(result); }); 注意: IE8 及之前版本的浏览器并不支持上述两个属性，而是提供了 document.selection 对象，用于保存整个 HTML 页面文档范围内选择的文本内容。 3. 获取部分的文本内容 HTML5 新版本中提供了 setSelectionRange() 方法，该方法用于从一个获取焦点的文本框中选择指定的文本内容。 setSelectionRange() 方法语法格式如下: inputElement.setSelectionRange(selectionStart, selectionEnd, [optional] selectionDirection); 在上述语法格式中的参数，具体说明如下: 参数名 描述 selectionStart 被选中的第一个字符的位置 selectionEnd 被选中的最后一个字符的 下一个 位置 selectionDirection 一个指明选择方向的字符串。有 \"forward\"、\"backward\" 和 \"none\" 3个可选值, 分别表示\"从前往后\", \"从后往前\"和\"选择方向未知或不重要\" 我们可以通过如下示例代码，学习 setSelectionRange() 方法的使用: var username = document.getElementById('username'); username.addEventListener('focus',function(){ username.setSelectionRange(0, -1);// 全部选中 }); 注意: IE8 及之前版本的浏览器并不支持这个方法。 过滤输入 在实际开发中，我们经常需要用户输入特定的内容，或者过滤不允许用户输入的内容。而利用 DOM 中的事件和 JavaScript 语言中的一些内容，就可以将一个普通的文本输入框改变成带有功能的控件。 1. 屏蔽字符 有时候，我们需要用户输入特定的文本内容或者不能输入特定的文本内容，例如电话号码中不能出现非数字的文本内容等。 我们可以通过为指定文本输入框元素注册 keypress 事件，并且在该事件的处理函数中阻止默认行为的方式实现屏蔽字符的功能。如下示例代码所示: var username = document.getElementById('username'); username.addEventListener('keypress',function(event){ event.preventDefault();// 阻止默认行为 }); 上述示例代码阻止了 keypress 事件，导致该文本输入框元素变成了只读的。 注意: 上述示例代码无法屏蔽中文输入法输入的文本内容。 当然，如果想要屏蔽指定的文本内容的话，只需在 keypress 事件的处理函数中利用正则表达式检测用户输入的内容，再做出相应的反馈即可。如下示例代码所示: var username = document.getElementById('username'); username.addEventListener('keypress',function(event){ var charCode = event.key; console.log(charCode); if (!/\\d/.test(charCode)) { event.preventDefault();// 阻止默认行为 } }); 上述示例代码中在 keypress 事件的处理函数中，先是获取了用户输入的文本内容，再判断是否为数字，如果不是则阻止输入。换句话讲，上述示例代码实现了只能允许用户输入数字内容。 2. 操作剪切板 剪切板功能是经常被忽略，却很重要的功能，可以增强用户体验，方便用户交互。以下三个事件是剪切板的主要操作: 事件名称 描述 copy 在发生复制操作时触发，对应的快捷键为 Ctrl/Cmd + C cut 在发生剪切操作时触发，对应的快捷键为 Ctrl/Cmd + X paste 在发生粘贴操作时触发，对应的快捷键为 Ctrl/Cmd + V 由于没有针对剪贴板操作的标准，这些事件及相关对象会因浏览器而异。如下图所示，就是上述三个事件的浏览器兼容性情况: 我们可以通过以下示例代码，学习上述三个事件的使用: var username = document.getElementById('username'); username.addEventListener('copy',callback); username.addEventListener('cut',callback); username.addEventListener('paste',callback); function callback(event){ var target = event.target || event.srcElement; target.value = event.type; } 上述示例代码将触发的事件类型输出在指定的输入框中。 Event 事件对象的 clipboardData 属性存储了由用户触发剪切板事件时所影响的带有 MIME 类型的数据。 注意: 如果是 IE 8及之前版本的浏览器的话，clipboardData 属性需要通过 window 对象获取。 var clipboardData = event.clipboardData || window.clipboardData; 该属性得到的是一个 DataTransfer 对象，该对象提供了操作数据的常用方法，如下表所示: 方法名称 描述 setData(in String type, in String data) 为一个给定的类型设置数据 getData(in String type) 根据指定的类型检索数据 clearData([in String type]) 删除与给定类型关联的数据 我们可以通过以下示例代码，学习如何使用上述 DataTransfer 对象的三个方法: 请输入你的用户名 var username = document.getElementById('username'); username.addEventListener('paste',function(event){ var target = event.target || event.srcElement; var clipboardData = event.clipboardData || window.clipboardData; var value = clipboardData.getData('text'); target.value = value; event.preventDefault(); }); 上述示例代码禁用了默认的粘贴事件，通过 clipboardData 属性的 getData() 方法获取剪切板中的数据并赋值给指定的输入框。 下拉列表的操作 下拉列表是由 和 元素创建的。 元素在 DOM 中对应的是 HTMLSelectElement 对象， 元素在 DOM 中对应的是 HTMLOptionElement 对象，这两个对象都提供了一些属性和方法，方便操作下拉列表。 HTMLSelectElement 对象 HTMLSelectElement 对象是 元素在 DOM 中对应的对象，在表单中获取该元素可以通过如下示例代码所示的方式: var selectbox = document.forms[0].elements['location']; 上述示例代码中，elements[] 中传递的是 元素的 name 属性值。 HTMLSelectElement 对象提供的属性如下表所示: 属性名称 描述 length 表示当前 元素中 元素的个数 multiple 表示 元素是否允许多项选择，等价于 HTML 中的 multiple 属性 options 当前 元素中 元素对象的集合 selectedIndex 代表第一个被选中的 元素。-1 代表没有元素被选中 size 当前 元素中可见的行数，等价于 HTML 中的 size 属性 1. 下拉单选框 下拉单选框就是指每次只能选择一个 元素的下拉列表。 我们可以通过如下示例代码，学习如何使用上述 HTMLSelectElement 对象的属性: 男 女 var selectbox = document.forms[0].elements['sex']; console.log('下拉列表元素的个数: ' + selectbox.length); console.log('下拉列表被选中的元素的索引值:' + selectbox.selectedIndex); 注意: selectedIndex 属性只能返回第一个被选中的 元素的索引值。 2. 下拉多选框 下拉多选框就是指每次可以选择多个 元素的下拉列表（必须定义 multiple 属性），并且可以通过 size 属性设置默认显示的个数。 我们可以通过如下示例代码，学习如何使用上述 HTMLSelectElement 对象的属性: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; console.log('第一个下拉列表是否为多选:' + selectbox.multiple); console.log('第一个下拉列表默认显示的个数:' + selectbox.size); HTMLSelectElement 对象提供的方法如下表所示: 属性名称 描述 add(item[, before]) 将 元素添加到当前 元素的选项元素集合中 item(idx) 放回索引值为 idx 的 元素。如果没有，则返回 null remove(index) 从当前 元素的选项元素集合中删除指定索引值的 元素 3. 添加选项 想要动态创建 元素并且添加到指定 元素的选项列表中的话，可以有多种方式实现。 第一种方式，利用之前已经掌握创建节点的方式实现。如下示例代码所示: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; var optionElem = document.createElement('option'); optionElem.appendChild(document.createTextNode('上海')); optionElem.setAttribute('value','shanghai'); selectbox.appendChild(optionElem); 第二种方式，通过 HTMLOptionElement 对象的构造函数 Option() 实现。如下示例代码所示: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; var optionElem = new Option('上海','shanghai'); selectbox.appendChild(optionElem); 注意: 上述的第二种方式在 IE 8及之前版本的浏览器，不能正确设置新选项的文本。 第三种方式，利用 HTMLSelectElement 对象的 add() 方法实现。如下示例代码所示: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; var optionElem = new Option('上海','shanghai'); selectbox.add(optionElem); 上述示例代码，将新选项添加到了 元素的选项集合中的最后面。如果想要添加到指定位置的话，可以通过如下示例代码所示的方式实现: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; var oldOptn = selectbox.options[2]; var optionElem = new Option('上海','shanghai'); selectbox.add(optionElem, oldOptn); 上述三种方式实现添加选项，建议使用第三种方式。第三种方式不仅代码更少，而且没有浏览器兼容性问题。 2. 删除选项 和添加选项类似，删除选项也具有多种方式实现。首先，第一种方式就是使用 DOM 中 Node 对象的 removeChild() 方法实现。如下示例代码所示: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; selectbox.removeChild(selectbox.options[1]);// 删除第二个选项 第二种方式，利用 HTMLSelectElement 对象的 remove() 方法实现。如下示例代码所示: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; selectbox.remove(1);// 删除第二个选项 第三种方式，利用 null 值释放资源的特性实现。如下示例代码所示: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; selectbox.options[1] = null;// 删除第二个选项 HTMLOptionElement 对象 HTMLOptionElement 对象是 元素在 DOM 中对应的对象，在表单中获取该元素可以通过如下示例代码所示的方式: var optElem = selectbox.options[index]; 而不推荐通过如下方式获取 元素: var optElem = selectbox.childNodes[index]; 上述这种方式可能出现空白节点问题。当然，我们还可以利用 Element 对象的 getElementsByTagName() 方法获取: var opsElem = selectbox.getElementsByTagName('option')[index]; 上述这种方式是通过查找 DOM 树结构实现。 HTMLOptionElement 对象提供的方法如下表所示: 属性名称 描述 index 当前 元素在其所属的选项列表中的索引值 selected 表示当前 元素是否被选中 text 当前 元素的文本内容 value 当前 元素的 value 属性值 我们可以通过如下示例代码，学习如何使用 HTMLOptionElement 对象的属性: 北京 南京 天津 重庆 var selectbox = document.forms[0].elements['location']; var optElem = selectbox.options[0]; console.log('当前选项的索引值: ' + optElem.index); console.log('当前选项是否被选中: ' + optElem.selected); console.log('当前选项的文本为: ' + optElem.text); console.log('当前选项的value为: ' + optElem.value); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-05 13:07:19 "},"chapter7/form-validate.html":{"url":"chapter7/form-validate.html","title":"第三节 表单验证","keywords":"","body":"所谓表单验证，就是用户输入内容的格式是否与开发人员预定义的要求相符。如下图所示: 上述示例演示了用户输入内容不能为空的效果。当然，真正的表单验证还可以完成很多类似这样的功能，例如输入一个合法的 Email 地址等功能。 之所以需要表单验证这样的功能，主要原因如以下几种: 希望用户输入符合产品要求格式的内容。比如用户在注册用户时使用的用户名可能是中文，这可能会引起一些问题，可以通过表单验证要求用户输入符合格式要求的用户名等。 有效保护用户数据。比如用户在注册用户时所使用的密码过于简单，可以通过表单验证要求用户输入符合格式要求的复杂密码等。 有效保护产品安全。如果没有表单验证，用户可能会输入任何带有恶意的内容。 目前，表单验证的实现手段主要有以下两种方式实现: 客户端页面的表单验证。这种方式主要是在提交表单之前，验证用户输入的数据是否符合要求。如果符合则提交表单，如果不符合则要求用户重新输入。 服务器端的校验。这种方式就是表单提交给服务器端，服务器端接收客户端的请求数据后，进行数据的校验工作。然后，根据校验结果做出相应的反馈。 本教程主要以客户端的表单验证为主进行讲解。 JavaScript 验证 JavaScript 方式的表单验证主要应用在 HTML5 版本发布之前，通过 JavaScript 代码逻辑自定义表单验证功能。 通过 JavaScript 代码方式实现表单验证功能，主要具有以下几种方式的实现: 主动过滤用户输入内容（这部分内容，可以参考《表单操作》的过滤输入） 逐一验证用户输入的每一条数据内容 在表单提交前，统一验证用户输入的数据内容（这部分内容，可以参考《表单提交》的如何提交表单） 这里主要以上述中的第二种方式进行实现。 首先，定义一个用于验证的表单。如下示例代码所示: 然后，为表单中的文本输入框注册 blur 事件。如下示例代码所示: var myform = document.forms[0]; var inputElem = myform.elements[0]; inputElem.addEventListener('blur',function(){ // 验证逻辑 }); 在 blur 事件的处理函数中，可以编写用于验证的代码逻辑。如下示例代码所示: var myform = document.forms[0]; var inputElem = myform.elements[0]; inputElem.addEventListener('blur',function(event){ // 验证逻辑 var target = event.target || event.srcElement; if (target.value == null || target.value == ''){ alert('请输入必要的内容'); } }); 上述示例代码实现了当文本输入框失去焦点时，判断文本输入框中是否为空。如果为空，则弹出提示框；如果不为空，不做任何处理。如下图所示: 说明: 这里注册的事件和验证逻辑都可以根据具体要求进行编写。 HTML5 内置验证 HTML5 版本提供了有关表单验证的元素、属性、状态及方法等内容，以简化表单验证的逻辑。 具有验证功能的元素 HTML5 版本对 元素新增了类型，其中一些类型带有验证功能。如下表所示: 类型 描述 说明 email 邮箱类型 判断当前字符串中是否包含@符号 url 网址类型 判断当前字符串中是否包含http:// number 数字类型 判断当前字符中是否为数字值 date 日期类型 按照 ISO 8601 编码的日期（包括年，月，日） month 月份类型 由 ISO 8601 编码的年和月组成的日期 week 星期类型 由 ISO 8601 编码的年和星期数组成的日期 1. email 类型 email 类型的 元素专门用于输入 email 地址。但 email 类型只能验证 email 地址的格式，并不能验证 email 地址的有效性。 我们可以通过如下示例代码，学习如何使用 email 类型: email: 上述示例代码运行后，如果输入的内容并不是有效的 email 地址的话，得到的效果如下图所示: 上述示例图中，表示 email 类型的规则是: 提交表单时，检查 email 类型的文本框中是否包含 @ 符号。 2. url 类型 url 类型的 元素专门用于输入 url 地址。 我们可以通过如下示例代码，学习如何使用 url 类型: url: 上述示例代码运行后，如果输入的内容并不是有效的 url 地址的话，得到的效果如下图所示: 上述示例图中，表示 url 类型的规则是: 提交表单时，检查 url 类型的文本框中是否包含 http:// 符号。 3. number 类型 number 类型的 元素专门用于输入数字。 我们可以通过如下示例代码，学习如何使用 number 类型: number: 上述示例代码运行后，如果输入的内容并不是有效的数字的话，得到的效果如下图所示: 上述示例图中，表示 number 类型的规则是: 提交表单时，检查 number 类型的文本框中是是否为数字。 4. date 类型 date 类型的 元素专门用于输入日期，提供日期选择控件。 我们可以通过如下示例代码，学习如何使用 date 类型: date: 上述示例代码运行后，得到的效果如下图所示: 上述示例图中，表示 date 类型提供了当用户单击向下箭头按钮时浏览器页面中显示日历。 说明: month 和 week 类型的效果类似于 date 类型。 带有验证功能的属性 HTML5 版本新增了带有验证功能的属性，如下表所示: 属性名称 描述 required 验证不为空 pattern 匹配正则表达式 min 和 max 验证最小值和最大值 minlength 和 maxlength 验证最小长度和最大长度 validity 获取validityState对象 1. required 属性 required 属性规定在表单提交之前必须填入内容（不能为空）。 说明: required 属性适用于 元素的以下类型: text、search、url、tel、email、password、date、number、checkbox、radio 及 file。 我们可以通过如下示例代码，学习如何使用 required 属性: 上述示例代码点击提交按钮运行后，得到的效果如下图所示: 2. pattern 属性 pattern 属性的值与指定的正则表达式进行匹配（一般用于验证特定格式）。 说明: pattern 属性适用于 元素的以下类型: text、search、url、tel、email 及 password。 我们可以通过如下示例代码，学习如何使用 pattern 属性: 上述示例代码点击提交按钮运行后，得到的效果如下图所示: 3. min 和 max 属性 min、max 和 step 属性用于为包含数字或日期的 元素规定数字或日期的范围和步长。 说明: min、max 和 step 属性适用于 元素的以下类型: date、number 及 range。 我们可以通过如下示例代码，学习如何使用 min、max 和 step 属性: 日期: 数字: 上述示例代码点击提交按钮运行后，得到的效果如下图所示: 上述示例中，date 类型为主动过滤效果。也就是说，在选择日期时的范围为 1979-12-31 到 2000-01-02 之间。 4. minlength 和 maxlength 属性 minlength 属性用于规定输入内容的最小长度，maxlength 属性用户对顶输入内容的最大长度。 minlength 和 maxlength 属性都为主动过滤属性。也就是说，一旦设置便不能超过这个范围。 我们可以通过如下示例代码，学习如何使用 minlength 和 maxlength 属性: HTML5 验证 API 除了上述 HTML5 提供的带有验证的元素和属性之外，HTML5 还提供了一组用于表单验证的 API。目前主流浏览器对 HTML5 提供的验证 API 支持越来越好。 验证 API 的属性 属性 描述 validationMessage 一个本地化消息，描述元素不满足验证条件时（如果有的话）的文本信息 validity 一个 ValidityState 对象，描述元素的验证状态 validity.customError 如果元素设置了自定义错误，返回 true ；否则返回false validity.patternMismatch 如果元素的值不匹配所设置的正则表达式，返回 true，否则返回 false validity.rangeOverflow 如果元素的值高于所设置的最大值，返回 true，否则返回 false validity.rangeUnderflow 如果元素的值低于所设置的最小值，返回 true，否则返回 false validity.stepMismatch 如果元素的值不符合 step 属性的规则，返回 true，否则返回 false validity.tooLong 如果元素的值超过所设置的最大长度，返回 true，否则返回 false validity.typeMismatch 如果元素的值出现语法错误，返回 true，否则返回 false validity.valid 如果元素的值不存在验证问题，返回 true，否则返回 false validity.valueMissing 如果元素设置了 required 属性且值为空，返回 true，否则返回 false willValidate 如果元素在表单提交时将被验证，返回 true，否则返回 false 说明: 上述表中 validatyState 对象的属性（有效状态）具有时效性。 验证 API 的方法 方法 描述 checkValidity() 如果元素的值不存在验证问题，返回 true，否则返回 false setCustomValidity(message) 为元素添加一个自定义的错误消息；如果设置了自定义错误消息，则该元素被认为是无效的，并显示指定的错误 1. 验证 API 的属性 HTML5 提供的验证 API 的属性需要配合 HTML5 新增的带有验证功能的属性一起使用。可以通过如下示例代码，学习如何使用这些验证 API 的属性: 用户名: 密码: Email: 年龄: var user = document.getElementById(\"user\"); user.onblur = function(){ if(user.validity.valid){ alert(\"验证通过.\"); }else if(user.validity.valueMissing){ alert(\"用户名为空.\"); } } var pwd = document.getElementById(\"pwd\"); pwd.onblur = function(){ if(pwd.validity.valid){ alert(\"验证通过.\"); }else if(pwd.validity.patternMismatch){ alert(\"密码输入有误.\"); } } var mail = document.getElementById(\"mail\"); mail.onblur = function(){ if(mail.validity.valid){ alert(\"验证通过.\"); }else if(mail.validity.typeMismatch){ alert(\"Email输入有误.\"); } } var age = document.getElementById(\"age\"); age.onblur = function(){ if(age.validity.valid){ alert(\"验证通过.\"); }else if(age.validity.rangeUnderflow){ alert(\"年龄过小.\"); }else if(age.validity.stepMismatch){ alert(\"年龄有误.\"); } } 上述示例代码运行后，得到的效果如下图所示: 2. setCustomValidity() 方法 setCustomValidity() 方法设置自定义验证信息，用于即将实施与验证的约束来覆盖预定义的信息。 var data = document.getElementById(\"data\"); data.onblur = function(){ if(data.validity.valueMissing){ data.setCustomValidity(\"不能为空.\"); }else if(data.validity.customError){ data.setCustomValidity(\"\"); } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-12 16:39:50 "},"chapter7/form-submit.html":{"url":"chapter7/form-submit.html","title":"第四节 表单提交","keywords":"","body":"提交表单，实际上就是将表单内组件用户输入的数据内容发送给指定的服务器端。例如用户登录、用户注册、购买商品的提交订单等功能，都是通过提交表单实现的。例如如下示例代码所示，就是一个简单的表单提交代码: 说明: 上述示例代码作为演示作用，不需要掌握。 客户端/服务器体系结构 当在页面中提交表单时，表单中的数据内容发生了什么呢？实际上，所有的 Web 应用程序都是具有两端的，一个是客户端（PC 端或者移动端等），一个是服务器端，客户端和服务器端才构成一个比较完整的 Web 应用程序。 客户端通过提交表单使用 HTTP 协议将数据内容发送给服务器端，服务器端使用同样的协议对客户端做出回应。如下图所示: 需要说明的是，客户端页面中的表单不过是提供给用户一个友好的体验。完全可以通过 HTTP 协议的请求协议完成数据的发送工作。 说明: 关于 HTTP 协议的内容，会有专门的教程讲解。 定义如何发送数据 表单想要实现提交功能，必须要配合使用提交按钮才能实现。只要在表单中出现如下任意一个按钮，都可以实现提交表单的功能: 提交按钮: 自定义提交按钮: 提交 图像按钮: 当然，想要提交表单，需要一个 表单元素配合一个提交按钮只是最基本的要求。而 表单元素也提供了与发送数据相关的两个属性。 action 属性 action 属性定义了发送数据的位置，该属性的值必须是一个有效的 URL。如果没有提供此属性，则数据将被发送到包含表单的页面的 URL。 该属性的值可以是一个绝对的 URL，如下示例代码所示: 也可以是一个相对的 URL，如下示例代码所示: 在没有定义 action 属性的值时，表单数据会被发送到当前表单所在页面的 URL 上。如下示例代码所示: 上述示例代码，需要注意的是这是 HTML5 的写法，也就是说，在 HTML5 版本之前，上述情况要写成如下示例代码所示: method 属性 method 属性定义了发送数据的方式，该属性的值由 HTTP 协议提供，主要使用的是 GET 和 POST 两种。 1. GET 方式 GET 方式是表单提交默认使用的请求方式。可以通过如下示例代码测试 GET 方式: 通过上述示例代码提交表单的话，可以在浏览器的地址栏中看到如下图所示的结果: 如上图所示，数据被附加到 URL 作为一系列的名称/值对。在 URL 地址结束之后，包括一个问号(?)，后面是名称/值对，每一个都由一个与符号(&)分隔开。 通过浏览器提供的开发者工具的 Network 功能抓取网络信息，会得到如下图所示的效果: 通过 GET 方式提交表单的话，会有以下问题: GET 方式提交表单数据大小有限制，理论上最多只能是 1024 字节 GET 方式提交表单将数据添加到浏览器的地址栏，安全性较低 2. POST 方式 POST 方式是表单提交比较常用的请求方式。可以通过如下示例代码测试 POST 方式: 通过上述示例代码提交表单的话，可以发现在浏览器的地址栏中并没有任何变化，如下图所示: 如上图所示，POST 方式提交表单时数据并没有被添加到 URL 地址中，而是被添加到了 HTTP 请求协议中。如下图所示: enctype 属性 表单中还具有一个比较特殊的属性 enctype，该属性定义提交表单时所生成的请求中的 Content-Type 的 HTTP 数据头的值。 enctype 属性的默认值为 application/x-www-form-urlencoded，该值的含义就是表示“这是已编码为URL参数的表单数据”。还具有另一个值为 multipart/form-data，可用于实现文件上传功能。如果想要实现文件上传功能，需要同时满足以下三个条件: 将表单的 method 属性值设置为 POST 将表单的 enctype 属性值设置为 multipart/form-data 表单组件中至少定义一个文件域 可以通过如下示例代码测试文件上传功能: 上述示例代码运行后的结果如下图所示: 如上图所示，可以看到 HTTP 请求协议中的 Content-Type 的值被修改为 multipart/form-data，这是由表单的 enctype 属性的值决定的。一旦设置为 multipart/form-data 值之后，表示表单提交的是二进制数据，可用于实现文件上传。 如何提交表单 submit 事件 以上述方式提交表单时，会触发 submit 事件。可以通过如下示例代码进行测试: var myform = document.forms[0]; myform.addEventListener('submit',function(){ alert('表单被提交......'); }); 上述示例代码运行后的效果如下图: 如果在 submit 事件的处理函数中通过 event 事件对象的 preventDefault() 方法可以阻止表单提交。换句话讲，在该事件的处理函数中可以完成表单验证的逻辑内容。 submit() 方法 表单还提供了 submit() 方法用于提交表单，使用该方法时允许表单内使用任一普通按钮即可（并非提交按钮）。 可以通过如下示例代码测试 submit() 方法的使用: var btn = document.getElementById('btn'); btn.addEventListener('click',function(){ var myform = document.forms[1]; myform.submit(); }); 上述示例代码中，首先为按钮注册 click 事件，然后在 click 事件的处理函数中获取表单并调用 submit() 方法，最终实现提交表单的功能。 注意: 使用 submit() 方法提交表单不会触发 submit 事件。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-09 14:58:58 "},"chapter8/what-is-bom.html":{"url":"chapter8/what-is-bom.html","title":"第八章 BOM","keywords":"","body":"BOM 的全称为 Browser Object Model，被译为浏览器对象模型。 BOM 提供了独立于 HTML 页面内容，而与浏览器相关的一系列对象。主要被用于管理浏览器窗口及与浏览器窗口之间通信等功能。 BOM 由一系列对象构成，这些对象可以简单理解为是由各个浏览器所提供的，例如 Window 对象等。 值得注意的是: BOM 是 JavaScript 中唯一一个没有标准的。 BOM 关系图 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:47:22 "},"chapter8/window-object.html":{"url":"chapter8/window-object.html","title":"第二节 Window 对象","keywords":"","body":"BOM 中最核心的对象就是 Window 对象，该对象表示运行 HTML 页面的浏览器窗口。 在浏览器环境中，Window 对象具有双重角色。该对象既是允许 JavaScript 逻辑访问浏览器窗口的一个对象，又是 ECMAScript 规范中的 Global 全局对象。 这就说明了，我们在浏览器环境中运行 JavaScript 逻辑时，在全局作用域中定义的对象、变量和函数都是 Window 对象的属性和方法。 我们也可以通过 Window 对象访问 Global 全局对象的属性和方法。例如 NaN、undefined 和 parseInt() 方法等。 全局作用域 在浏览器环境中，由于 ECMAScript 规范中 Window 对象代表了 Global 全局对象，因此所有定义在全局作用域中的变量和函数，都可以通过 Window 对象的属性和方法方式访问。 var name = '全栈讲师'; function fn(){ console.log('EASYDOM系列教程'); } // 全局变量和全局函数方式访问 console.log(name); fn(); // Window 对象的属性和方法方式访问 console.log(window.name); window.fn(); 值得注意的是: 定义全局变量和定义 Window 对象的属性，在操作时还是有差别的: 如果是全局变量的话，不能使用 delete 运算符进行删除。 如果是 Window 对象的属性的话，允许使用 delete 运算符进行删除。 var name = '金云龙'; window.job = '全栈讲师'; // 使用 delete 运算符进行删除 delete window.name; delete window.job; // 删除之后调用测试结果 console.log(window.name); console.log(window.job); 上述示例代码的执行结果如下: Window 对象的属性 Window 对象的属性数量较多，包含了浏览器窗口的基本信息、也包含了一些复杂的信息。我们可以人为将 Window 对象分为以下三类: BOM 中其他对象，例如 Navigator 对象等。 一些有关浏览器窗口的基本信息等，这些属性多属于 DOM 0 级别，并不是 W3C 标准规范。 包含了大量有关 HTML 5 版本新增的功能等。 浏览器窗口的宽度和高度 Window 对象提供的属性中可以获取当前浏览器窗口的宽度和高度，具有两组: innerWidth 和 innerHeight 属性: 只读属性，返回当前浏览器窗口的可视宽度和高度。如果存在滚动条，也包含滚动条。 outterWidth 和 outterHeight 属性: 只读属性，返回当前浏览器窗口的整个宽度和高度。 Window 对象与 self 属性 Window 对象的 self 属性返回当前浏览器窗口的只读属性。换句话讲，self 属性返回的是 Window 对象的引用。 我们可以通过以下方式来测试 self 属性: console.log(window == window.self); 我们也可以通过以下代码判断当前浏览器是否是最顶层窗口: if (window.top != window.self) { console.log(\"这个窗口不是最顶层窗口\"); }else{ console.log(\"这个窗口是最顶层窗口\"); } Window 对象的方法 Window 对象的方法，我们主要从以下几方面进行学习: 系统提示框：alert() 方法、confirm() 方法和 prompt() 方法 打开与关闭窗口：open() 与 close() 方法、 showModalDialog() DOM 规范标准 0 级别的一些方法 定时器：setTimeout() 与 clearTimeout() 、setInterval() 与 clearInterval() 值得注意的是: Window 对象的方法不止以上四种，还包含 HTML 5 版本新增方法和一些已经废弃的方法等。 系统提示框 提示框方法 alert('这是一个提示框'); 确认框方法 var result = confirm('这是一个确认框'); 输入框方法 var result = prompt('这是一个标准输入框','这是默认提示内容'); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 22:47:48 "},"chapter8/navigator-object.html":{"url":"chapter8/navigator-object.html","title":"第三节 Navigator 对象","keywords":"","body":"Navigator 对象包含了一些有关浏览器状态的信息。可以通过 window.navigator 属性得到 Navigator 对象。 常见属性 Navigator 对象提供一系列常用属性，获取当前浏览器的信息。具体内容如下: 属性名称 描述 appCodeName 浏览器的代码名 appName 浏览器的名称 appVersion 浏览器的平台和版本信息 platform 运行浏览器的操作系统平台 我们可以通过以下代码示例，测试上述 Navigator 对象的常见属性: console.log('浏览器的代码名: ' + navigator.appCodeName); console.log('浏览器的名称: ' + navigator.appName); console.log('浏览器的平台和版本信息: ' + navigator.appVersion); console.log('运行浏览器的操作系统平台: ' + navigator.platform); userAgent 属性 Navigator 对象提供很多属性，可以来识别当前浏览器及操作系统信息。但绝大多数属性在目前浏览器中已经不再起作用了。 而 Navigator 对象的 userAgent 属性依旧可以实现识别浏览器的功能。userAgent 属性返回由客户机发送服务器的 user-agent 头部的值。userAgent 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。 以下列表罗列了不同浏览器的 userAgent 属性的值: 浏览器产品 userAgent 属性值 Firefox Mozilla/5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0 Chrome Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36 IE 8 Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE 11 Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko Safari Mozilla/5.0 (Macintosh; Intel Mac OS X 10124) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30 用户的浏览器产品 通过 userAgent 属性获取用户当前使用的浏览器产品，提供浏览器兼容解决方案。如下代码所示: var ua = navigator.userAgent; if(/firefox/i.test(ua)){ console.log('当前使用的是 Firefox 浏览器'); }else if(/chrome/i.test(ua)){ console.log('当前使用的是 Chrome 浏览器'); }else if(/safari/i.test(ua)){ console.log('当前使用的是 Safari 浏览器'); }else if(/msie/i.test(ua)){ console.log('当前使用的是 IE 11 之前版本的浏览器'); }else if(\"ActiveXObject\" in window){ console.log('当前使用的是 IE 11 浏览器'); } 用户的操作系统信息 通过 userAgent 属性获取用户当前使用的操作系统信息，具体代码示例如下: if (/windows/i.test(ua)){ console.log('当前使用的是 Windows 操作系统'); }else if (/mac/i.test(ua)){ console.log('当前使用的是 Mac 操作系统'); }else if (/android/i.test(ua)){ console.log('当前使用的是 Android 操作系统'); }else if (/iphone/i.test(ua)){ console.log('当前使用的是 iPhone 操作系统'); } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:37:01 "},"chapter8/history-object.html":{"url":"chapter8/history-object.html","title":"第四节 History 对象","keywords":"","body":"History 对象包含用户在浏览器中访问过的 URL（网址）。 length 属性: History 对象的 length 属性可以获取用户在浏览器中访问网址的数量。 console.log('用户访问的网址数量为: ' + history.length); History 对象还提供了以下方法实现浏览器前进和后退功能。 方法名称 描述 forward() 实现跳转下一个页面，作用和浏览器的前进按钮一样 back() 实现转跳到上一个页面，作用和浏览器的回退按钮一样 go() 实现跳转到指定的页面。如果为负数表示后退，如果为正数表示前进 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:37:21 "},"chapter8/location-object.html":{"url":"chapter8/location-object.html","title":"第五节 Location 对象","keywords":"","body":"Location 对象包含了浏览器的地址栏中的信息，该对象主要用于获取和设置地址。 Location 对象很特别，因为该对象既是 Window 对象的属性，又是 Document 对象的属性。 console.log(window.location == document.location);// true History 对象的属性 Location 对象不仅存储了地址栏中的信息，还提供了解析功能。可以通过不同的 Location 对象的属性访问不同的地址栏中的信息。 属性名称 描述 host 返回服务器名称和端口号 hostname 返回服务器名称 href 返回当前加载页面的完整 URL pathname 返回当前 URL 中的目录和文件名 port 返回当前 URL 中的端口号 protocol 返回页面使用的网络协议 获取和设置地址 通过可以获取和设置浏览器的地址栏中的地址信息。 // 获取当前浏览器窗口的地址栏信息 console.log('Location对象为: ' + window.location); // 设置当前浏览器窗口的地址栏信息 window.location = 'http://www.longestory.com'; 上述功能我们同样可以通过 Location 对象的 href 属性完成。 // 获取当前浏览器窗口的地址栏信息 console.log('Location对象的href属性为: ' + location.href); // 设置当前浏览器窗口的地址栏信息 location.href = 'http://www.longestory.com'; 查询字符串参数 Location 对象提供了 search 属性，用于返回 URL 包含的查询字符串。 function getQueryStringArgs(){ // 取得查询字符串并去掉开头的问号 var qs = location.search.length > 0 ? location.search.substring(1) : ''; // 保存数据的对象 var args = {}; // 取得每一项 var items = qs.length ? qs.split('&') : []; var item = null, name = null, value = null, i = 0, len = items.length; // 逐个将每一项添加到 args 对象中 for (i=0; i History 对象的方法 Location 对象提供了以下方法: 方法名称 描述 assign() 载入一个新的文档，作用和直接修改 location 相同 reload() 重新载入当前文档，作用和刷新按钮一样。参数为 true 时，则会强制清空缓存刷新页面 replace() 用新的文档替换当前文档（不会生成历史记录，不能使用回退按钮回退） Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 21:37:39 "},"chapter8/time-out.html":{"url":"chapter8/time-out.html","title":"第六节 定时器","keywords":"","body":"第六节 定时器 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-04 13:38:56 "}}