{"./":{"url":"./","title":"关于","keywords":"","body":" 学习本套课程，需要你具备 HTML、CSS 以及 JavaScript 语法部分的基础。 前言 本套课程共分为 8 个章节，从基础的概念到具体的用法，一一详细的进行阐述。只为努力作为学习 DOM 技术的最好的自学课程。 本套课程会一直更新，直到达到适合于所有人自学为止。 8 个章节内容，大体上可以被分为以下几个部分内容: 说明: 如果你已经掌握 DOM 中的部分内容，可以根据自己的情况选择性的进行学习。 第一部分: 概念 我们首先从第一章节概念入手，先掌握什么是 DOM，以及 DOM 中非常重要的概念 DOM 树结构。 这部分内容，是你学习 DOM 中后续内容的基础。概念清晰了，操作才会更顺手。学习概念，不仅仅只是单纯地阅读文字这么简单。要试着用自己的话来描述你所学习的概念，并把它发布到网络上，让别人替你检查，你的理解是否准确。 如果你不知道如何发布到网络上，可以加入底部的 QQ 讨论群，与其他人共同学习。 第二部分: 核心对象 DOM 解析 HTML 页面，最主要的是依靠 Document、Node 和 Element 这三个核心对象完成的。所以，第二章、第三章和第四章是分别学习这三个核心对象。 这部分内容，作者在编写的过程中，尽量按照 W3C DOM 的规范标准进行编写。可能，学习掌握起来有一些难度。 不过，不要灰心! 作者会在后续的更新中，加入大量适当的案例，帮助你更好地掌握这部分内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 第三部分: 样式操作 DOM 解析 HTML 页面，其中很大部分是对 CSS 样式的操作。如今的 HTML 页面显示的效果越加复杂，主要都是由 CSS 样式完成的。 所以，掌握如何获取和设置 CSS 样式也就显得很重要了。但是，技术知识和实际操作还是会存在一些差异，这些差异作者也会在后续的案例更新中进行补充。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 第四部分: 事件 事件，目前作为 DOM 操作中很主要的组成部分，也是你学习 DOM 技术必须要掌握的技术知识。所以，作者在第六章节，利用了大量篇幅来阐述有关事件的内容。 说明: 目前课程中有关事件一章，并没有罗列出所有事件的用法和应用场景。 第五部分: 表单 表单，本身就是作为 HTML 页面技术中很重要的一个组成部分。而 DOM 操作表单也就变得重要了。 目前，大部分初学者都可以简单地掌握 DOM 操作表单的方式。但，很难全面系统地掌握，而很多容易忽视的内容，往往都是开发中比较常用的。 第六部分: BOM BOM，原本是作为 JavaScript 三个组成部分的其中一个，但由于篇幅较少，作者将其纳入到 DOM 课程之中。 反馈 本套课程会尽量完善，编写过程中难免出现纰漏。你可以通过以下展示方式进行反馈，作者会根据反馈及时更新和修改。 交流 你可以扫描下方的二维码，加入本套课程的 QQ 讨论群，与其他童鞋一起学习交流。 版权 本套课程的文本内容免费开源，任何人都可以免费学习、分享，甚至可以进行修改。但需要注明作者及来源，并且不能用于商业。 本套课程采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-03 13:23:12 "},"01-dom-summary/":{"url":"01-dom-summary/","title":"第一节 DOM 介绍","keywords":"","body":"DOM 是什么 DOM 被设计用于解析 HTML 页面文档，方便 JavaScript 语言通过 DOM 访问和操作 HTML 页面中的内容。 DOM 是由 W3C 组织定义标准规范，并且由各大浏览器厂商支持。严格意义上来讲，DOM 并非属于 JavaScript 语言。 在其他开发语言中，也支持 DOM 的标准规范，例如 PHP 语言。 我们之所以可以在 JavaScript 语言中使用 DOM，是因为各大浏览器将 DOM 的标准规范内容封装成了 JavaScript 语言所支持的形式。 对于 DOM 中的对象，我们只有调用的权限，没有修改的权限，也说明了这个问题。 DOM 的具体含义是什么 DOM 其实是个缩写，全称是 Document Object Model，被译为 文档对象模型。 其中 D 表示 Document，就是 DOM 将 HTML 页面解析为一个 文档。同时提供了 document 对象。 其次 O 表示 Object，就是 DOM 将 HTML 页面中每个元素解析为一个 对象。例如 元素在 DOM 中对应就是 HTMLBodyElement 对象。 最后 M 表示 Model，就是 DOM 中表示各个对象之间的关系。 模型（Model）主要是指 DOM 树结构。 DOM 是如何解析 HTML 页面的呢 浏览器加载并运行 HTML 页面后，会创建 DOM 结构。由于 DOM 中的内容被封装成了 JavaScript 语言中的对象，所以我们可以使用 JavaScript 语言通过 DOM 结构来访问和操作 HTML 页面中的内容。 换句话讲，DOM 可以理解为是 HTML 页面与 JavaScript 语言之间的一个桥梁。 DOM 的定义 由于 DOM 的标准规范是由 W3C 组织起草并定义的，所以 W3C 对 DOM 的定义是目前最权威的解释。 下面这段英文描述，就是 W3C 对 DOM 的定义原文: The Document Object Model is a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure and style of documents. The document can be further processed and the results of that processing can be incorporated back into the presented page. 下面这段是本人的翻译（仅供参考）: DOM 是一个独立于任何语言和平台的接口，允许任何语言或脚本动态地访问和更新 HTML 文档的内容、结构和样式。该 HTML 页面可以进一步处理，并且该处理的结果可以被合并到所呈现的 HTML 页面中。 DOM 标准是独立的 通过 W3C 的定义，我们可以知道 DOM 是不属于任何开发语言的。当然，DOM 也不会属于 JavaScript 语言。 任何一个开发语言，只要支持了 DOM 的标准规范，都可以通过 DOM 访问和操作 HTML 页面。 换句话讲，DOM 在不同开发语言中，有着不同的使用形式。但最核心的标准规范都是一样的，只是具体使用的开发语言的语法不同而已。 比如下面这段代码，就是 JavaScript 中的 DOM 内容: var btn = document.getElementById('btn'); var className = btn.className; className += ' animate'; btn.className = className; DOM 的作用 通过 W3C 的定义，我们还可以知道 DOM 主要是用来解析 HTML 页面的。也就是只要支持 DOM 的标准规范的开发语言，都可以通过 DOM 访问和更新 HTML 页面的内容、结构和样式。 早期的 DOM 除了可以访问和更新 HTML 页面外，还可以访问和更新 XML 文档。但目前 XML 文档的使用场景越来越少，再加上 Web 前端开发需求越来越多。导致 DOM 主要用来访问和更新 HTML 页面了。 浏览器的支持 目前几乎所有的浏览器都支持 DOM 的内容。但是不是支持的是 W3C 对 DOM 的标准规范呢？ 浏览器和 W3C 谁更早 浏览器对 DOM 的支持远早于 W3C 定义 DOM 的标准规范。也就是说，在 W3C 定义 DOM 的标准规范之前，各大浏览器就支持了 DOM。 最早，是 Navigator 浏览器支持 DOM。但只是提供了 Document 对象的一些属性和方法。 后期，IE 浏览器也加入了对 DOM 的支持。但 IE 浏览器与 Navigator 浏览器所支持的 DOM 是有区别的。 这也是 DOM 在不同浏览器中的兼容问题。 而 W3C 组织定义 DOM 的标准规范，主要也是为了解决 DOM 在不同浏览器的差异问题。 虽然，自从 W3C 定义了 DOM 的标准规范后，浏览器的兼容问题好了很多。但，各大浏览器都或多或少地扩展了 W3C 定义的 DOM 标准。 在实际开发中，尽量使用 W3C 的 DOM 标准规范，以避免更多的浏览器兼容问题。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:11:51 "},"02-dom-tree/":{"url":"02-dom-tree/","title":"第二节 DOM 树结构","keywords":"","body":"DOM 树结构 DOM 之所以可以访问和更新 HTML 页面中的内容、结构和样式，是因为 DOM 将 HTML 页面解析为一个 树结构。 例如下面这段代码是一个简单的 HTML 页面源代码: 示例页面 这是一个示例页面 这是一个段落内容. 将上面的 HTML 页面绘制成 DOM 树结构，如下效果: 通过上面的 DOM 树结构，我们可以看到，Document 对象是作为 DOM 树结构的入口。再根据 DOM 树结构的特点，我们就可以定位到 HTML 页面中任意一个元素、属性或文本内容。 浏览器加载并运行 HTML 页面时，会创建 DOM 树结构这个模型。并且 DOM 树结构模型会被存储在浏览器的内存中。 当 HTML 页面内容过于庞大和复杂时，生成的 DOM 树结构就越复杂。进而，浏览器加载 HTML 页面的耗时就越长。 什么是节点 节点（Node）原本是网络术语，表示网络中的连接点。一个网络是由一些节点构成的集合。 在 DOM 树结构中，节点也是很重要的一个概念。简单来说，节点作为 DOM 树结构中的连接点，最终构成了完整的 DOM 树结构。 DOM 树结构中的节点 在 DOM 树结构中，主要由以下 4 种节点组成: 节点名称 含义 描述 文档节点 表示整个 HTML 页面（相当于 document 对象） 当需要访问任何标签、属性或文本时，都可以通过文档节点进行导航 元素节点 表示 HTML 页面中的标签（即 HTML 页面的结构） 当访问 DOM 树时，需要从查找元素节点开始 属性节点 表示 HTML 页面中的开始标签包含的属性 文本节点 表示 HTML 页面中的标签所包含的文本内容 除了上面 4 种常见的节点类型以外，DOM 树结构中还具有很多节点类型。 还有一些节点类型，目前已被废弃（不再使用）。 DOM 节点树结构 通过节点概念，我们可以将原本的 DOM 树结构改成 DOM 节点树结构进行表示。 在 DOM 的标准规范中，提供了 Node 对象。该对象主要依靠 DOM 节点树结构中的常见 4 种节点类型，来访问和更新 HTML 页面中的内容。 关于 Node 对象，我们会在后面的章节中学习。 节点之间的关系 DOM 中的 M 表示 Model（模型），也可以用来表示 DOM 节点树结构中节点之间的关系。 在 DOM 节点树结构中，主要具有以下三层关系。 父级与子级 如果我们将 HTML 页面中某一个元素作为父级的话，那包含在该元素内的第一层所有元素都可以称为该元素的子级。 例如，我们来看一下下面这个 DOM 节点树结构: 在上面的 DOM 节点树结构中， 元素作为父级， 和 元素作为子级。 祖先与后代 如果我们将 HTML 页面中某一个元素作为祖先的话，那包含在该元素内的所有元素（除子级之外的）都可以称为该元素的后代。 例如，我们来看一下下面这个 DOM 节点树结构: 在上面的 DOM 节点树结构中， 元素作为祖先，、、 和 元素作为后代。 兄弟关系 具有相同父级元素的两个或几个元素之间就是兄弟关系。例如，我们来看一下下面这个 DOM 节点树结构: 在上面的 DOM 节点树结构中， 和 元素就是兄弟关系。因为它们具有相同的父级元素 。 值得注意的是: 和 元素并不是兄弟关系。因为它们的父级元素并不是相同元素。 DOM 访问和更新 HTML 页面中的内容，主要依靠 DOM 节点树结构中这三种节点关系完成。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:12:28 "},"03-document-summary/":{"url":"03-document-summary/","title":"第一节 Document 对象介绍","keywords":"","body":"Document 对象是 DOM 的标准规范中比较重要的对象之一。该对象提供了访问和更新 HTML 页面内容的属性和方法。 Document 对象的作用 Document 对象作为 DOM 访问和更新 HTML 页面内容的入口。简单来说，我们可以把 Document 对象理解为在 DOM 的标准规范中代表 HTML 页面。（当然，这种说法并不准确） Document 对象提供的属性和方法，可以实现定位 HTML 页面中的元素，或者创建新的元素等功能。 测试 Document 对象 我们可以通过 console.log 方法将 Document 对象打印，测试 Document 对象中提供了哪些属性和方法: console.log(document); 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: 我们会发现 console 会将 HTML 页面的源代码打印出来。这个结果充分地说明了 Document 对象在 DOM 的标准规范中代表整个 HTML 页面。 换句话讲，DOM 访问和更新 HTML 页面内容主要依靠 Document 对象作为入口。 Document 对象的属性和方法一览 在 DOM 的标准规范中，Document 对象的属性和方法被定义在了 prototype 原型中。所以，我们想要查看 Document 对象中具有哪些属性和方法，可以打印 Document 对象的 protoype 进行查看。 console.log(Document.prototype); 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: URL:(...) activeElement:(...) adoptNode:function adoptNode() anchors:(...) append:function append() applets:(...) baseURI:(...) body:(...) characterSet:(...) charset:(...) childElementCount:(...) childNodes:(...) children:(...) close:function close() contentType:(...) cookie:(...) createAttribute:function createAttribute() createElement:function createElement() createEvent:function createEvent() createExpression:function createExpression() createNSResolver:function createNSResolver() createNodeIterator:function createNodeIterator() createProcessingInstruction:function createProcessingInstruction() createRange:function createRange() createTextNode:function createTextNode() createTreeWalker:function createTreeWalker() currentScript:(...) defaultView:(...) designMode:(...) dir:(...) doctype:(...) documentElement:(...) documentURI:(...) domain:(...) firstChild:(...) firstElementChild:(...) fonts:(...) forms:(...) getElementById:function getElementById() getElementsByClassName:function getElementsByClassName() getElementsByName:function getElementsByName() getElementsByTagName:function getElementsByTagName() getSelection:function getSelection() hasFocus:function hasFocus() head:(...) hidden:(...) images:(...) implementation:(...) importNode:function importNode() inputEncoding:(...) isConnected:(...) lastChild:(...) lastElementChild:(...) lastModified:(...) links:(...) nextSibling:(...) nodeName:(...) nodeType:(...) nodeValue:(...) open:function open() ownerDocument:(...) parentElement:(...) parentNode:(...) prepend:function prepend() previousSibling:(...) querySelector:function querySelector() querySelectorAll:function querySelectorAll() readyState:(...) referrer:(...) registerElement:function registerElement() rootElement:(...) scripts:(...) scrollingElement:(...) selectedStylesheetSet:(...) styleSheets:(...) textContent:(...) title:(...) visibilityState:(...) write:function write() writeln:function writeln() 我们可以看到，Document 对象提供的属性和方法还是比较多的。但在实际开发中，比较常用的属性和方法并没有太多。 关于 Document 对象的具体用法，我们在后面的章节中学习。 Document 对象的继承链 Document 对象是继承于 Node 对象的。Node 对象也是 DOM 的标准规范中非常重要的对象之一，而 Node 对象又是继承于 EventTarget 对象。 我们可以通过以下代码来测试 Document 对象的继承链: console.log(Document.prototype instanceof Node); console.log(Node.prototype instanceof EventTarget); console.log(Document.prototype instanceof EventTarget); Document 对象的属性和方法多是继承于 Node 对象和 EventTarget 对象的。当然，也有一部分属性和方法是实现了 HTMLDocument 接口的。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:12:57 "},"04-location-element/":{"url":"04-location-element/","title":"第二节 定位页面元素","keywords":"","body":"Document 对象提供了属性和方法实现定位页面元素功能，这也是 DOM 的标准规范中 Document 对象的主要应用之一。 定位页面元素方法 目前 Document 对象提供实现定位页面元素的方法具有如下几种: getElementById()方法：通过页面元素的 id 属性值定位元素。 getElementsByName()方法：通过页面元素的 name 属性值定位元素。 getElementsByTagName()方法：通过页面元素的元素名定位元素。 getElementsByClassName()方法：通过页面元素的 class 属性值定位元素。 querySelector()方法：通过 CSS 选择器定位第一个匹配的元素。 querySelectorAll()方法：通过 CSS 选择器定位所有匹配的元素。 接下来，我们就一一进行学习。 通过元素的 ID 属性值定位元素 HTML 页面元素的 id 属性的特点是唯一、不可重复的，所以通过这种方式定位的 HTML 页面元素也是唯一的。 其语法格式如下: element = document.getElementById(id); 在上述语法中，id 是参数，表示所要定位元素的 id 属性值，是一个大小写敏感的字符串。element 是返回值，表示定位的元素，是一个 Element 对象。 值得注意的是: 如果 HTML 页面中不存在具有该 id 属性值的元素，则返回 null。 下面是使用 getElementById() 方法的示例代码: var btn = document.getElementById('btn'); // 获取定位元素的 class 属性值 var className = btn.className; // 添加 animate 动画样式 className += ' animate'; // 将新的 class 属性值设置 btn.className = className; 上述代码通过 getElementById() 方法定位 HTML 页面中 id 属性值为 btn 的元素，并为其元素的 class 属性添加 animate 样式。 通过元素的 name 属性值定位元素 其语法格式如下: elements = document.getElementsByName(name); 在上述语法中，name 是参数，表示所要定位元素的 name 属性值，是一个大小写敏感的字符串。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByName() 方法的示例代码: var elems = document.getElementsByName('btn'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByName() 方法定位 HTML 页面中 name 属性值为 btn 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 通过元素的元素名定位元素 其语法格式如下: elements = document.getElementsByTagName(name); 在上述语法中，name 是参数，表示所要定位元素的元素名，符号”*”表示所有元素。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByTagName() 方法的示例代码: var elems = document.getElementsByTagName('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByTagName() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 通过元素的 class 属性值定位元素 其语法格式如下: elements = document.getElementsByClassName(names); 在上述语法中，names 是参数，表示所要定位元素的 class 属性值列表，class 名称通过空格分隔。 值得注意的是: names 参数可以是一个样式属性名称，也可以是多个样式属性名称。 elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByClassName() 方法的示例代码: var elems = document.getElementsByClassName('btn'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByClassName() 方法定位 HTML 页面中 class 属性值为 btn 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 兼容 IE 8 及之前版本的浏览器 getElementsByClassName() 方法只支持 IE 9 版本及之后版本的浏览器。也就是说，该方法并不支持 IE 8 及之前版本的浏览器。 下图是不同浏览器的不同版本对 getElementsByClassName() 方法的支持情况: 由于国内的生产环境中，依旧存在使用 IE 8 及之前版本浏览器的情况。所以，我们需要自定义 getElementsByClassName() 方法解决浏览器的兼容问题。 function getElementsByClassName(element, names) { } 上述自定义兼容方法接受两个参数，element 参数表示调用 getElementsByClassName() 方法的对象（目前为 Document 对象），names 参数表示所要定位元素的 class 属性值列表。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 } } 这里我们要优先使用 W3C 规范的方法。所以，需要先判断当前浏览器环境是否存在 getElementsByClassName() 方法。 如果存在，就使用原本的 getElementsByClassName() 方法。如果不存在，就使用自定义代码来实现。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 // 获取所有后代元素节点 var elements = element.getElementsByTagName('*'); // 定义空数组 var result = []; var element, classNameStr, flag; // 将样式名称改为数组类型 names = names.split(' '); // 循环遍历所有元素节点 for (var i=0; element = elements[i]; i++) { // 获取每个元素节点的样式名称 classNameStr = ' ' + element.className + ' '; // 开启开关 flag = true; // 循环遍历所有的样式名称 for (var j=0, name; name = names[j]; j++) { // 判断当前元素节点的样式名称中是否包含指定的样式名称 if (classNameStr.indexOf(' ' + name + ' ') == -1){ // 如果不包含，则关闭开关，并且结束循环 flag = false; break; } } // 判断当前元素节点是否包含指定样式名称 if (flag) { // 如果包含，则将当前元素节点添加到数组中 result.push(element); } } // 返回数组(所有包含指定样式名称的元素节点) return result; } } 通过 CSS 选择器定位元素 CSS 中的选择器可以很便利地定位 HTML 页面元素，DOM 的标准规范中也提供类似的方法。 querySelector(): 定位匹配选择器的第一个元素。 querySelectorAll(): 定位匹配选择器的所有元素。 querySelector() 方法 其语法格式如下: element = document.querySelector(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。element 是返回值，表示定位元素的集合，匹配的第一个元素。 下面是使用 querySelector() 方法的示例代码: var btn = document.querySelector(’#btn'); // 获取定位元素的 class 属性值 var className = btn.className; // 添加 animate 动画样式 className += ' animate'; // 将新的 class 属性值设置 btn.className = className; 上述代码通过 querySelector() 方法定位 HTML 页面中 id 属性值为 btn 的元素，并为其元素的 class 属性添加 animate 样式。 querySelectorAll() 方法 其语法格式如下: elements = document.querySelectorAll(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 querySelectorAll() 方法的示例代码: var elems = document.querySelectorAll('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 querySelectorAll() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 节点集合 NodeList NodeList 是一组元素节点的集合，每个节点具有相应的索引值（从 0 开始的数字，类似于数组）。 元素节点在 NodeList 集合中存储的顺序与它们在 HTML 页面中的顺序保持一致。 NodeList 的属性 length 表示 NodeList 对象中包含的节点个数。方法 item(index) 表示返回 NodeList 对象中指定索引的节点。如果索引值越界,则返回 null。 NodeList 集合分为两种: 动态 NodeList 和静态 NodeList。 动态的 NodeList 集合 所谓动态的 NodeList 集合，就是如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。 以下几种定位 HTML 页面元素的方法返回的都是动态的 NodeList 集合。 getElementsByName()方法：通过页面元素的 name 属性值定位元素。 getElementsByTagName()方法：通过页面元素的元素名定位元素。 getElementsByClassName()方法：通过页面元素的 class 属性值定位元素。 我们可以通过以下示例代码，体验动态 NodeList 集合的特点: var elems = document.getElementsByTagName('button'); console.log(elems.length);// 输出 3 // 添加一个新的button按钮 var btn = document.createElement('button'); btn.setAttribute('class','button'); var text = document.createTextNode('New Button'); btn.appendChild(text); var div = document.getElementsByClassName('button-group')[0]; div.appendChild(btn); console.log(elems.length);// 输出 4 上述代码通过 getElementsByTagName() 方法定位 HTML 页面中所有的 button 元素，测试打印 button 元素的个数是 3 个。 然后，我们创建一个新的 button 元素，并且将其添加到 HTML 页面中，再测试打印 button 元素的个数是 4 个。 值得注意的是: 我们在第二次测试打印 button 元素的个数时，并没有重新定位 HTML 页面中的 button 元素。 静态 NodeList 集合 所谓静态 NodeList 集合，就是对文档对象模型的任何改动都不会影响集合的内容。 querySelectorAll() 方法定位 HTML 页面元素所返回的 NodeList 集合就是静态 NodeList 集合。 我们可以通过以下示例代码，体验静态 NodeList 集合的特点: var elems = document.querySelectorAll('button'); console.log(elems.length);// 输出 3 // 添加一个新的button按钮 var btn = document.createElement('button'); btn.setAttribute('class','button'); var text = document.createTextNode('New Button'); btn.appendChild(text); var div = document.getElementsByClassName('button-group')[0]; div.appendChild(btn); console.log(elems.length);// 输出 3 上述代码通过 querySelectorAll() 方法定位 HTML 页面中所有的 button 元素，测试打印 button 元素的个数是 3 个。 然后，我们创建一个新的 button 元素，并且将其添加到 HTML 页面中，再测试打印 button 元素的个数依旧是 3 个。 定位页面元素属性 Document 对象也提供了一些属性，来定位 HTML 页面中一些比较特殊的元素。 documentElement：获取 HTML 页面中的 元素。 head：获取 HTML 页面中的 元素。 title：获取 HTML 页面中的 元素。 body：获取 HTML 页面中的 元素。 links：获取 HTML 页面中的所有 元素。 images：获取 HTML 页面中的所有 元素。 我们可以定义一个包含以上元素的 HTML 页面，然后通过以下示例代码进行测试: console.log(document.documentElement); console.log(document.head); console.log(document.body); console.log(document.title); console.log(document.links); console.log(document.images); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:14:08 "},"05-create-element/":{"url":"05-create-element/","title":"第三节 创建页面元素","keywords":"","body":"Document 对象提供了可以创建元素节点、属性节点和文本节点的方法，方便 DOM 更新 HTML 页面中的元素。 创建元素节点 Document 对象提供了 createElement() 方法创建元素节点，其语法格式如下: element = document.createElement(tagName); 上述语法格式中，tagName 是参数，表示创建元素的元素名称。element 是返回值，表示创建的元素。 值得注意的是: createElement() 方法优先将参数转换为小写。 下面是使用 createElement() 方法的示例代码: var div = document.getElementById('group'); // 创建新的元素节点 var elem = document.createElement('button'); div.appendChild(elem); 上述示例代码通过 createElement() 方法创建了 button 元素，并将其添加到 HTML 页面中。 创建文本节点 Document 对象提供了 createTextNode() 方法创建文本节点，其语法格式如下: textNode = document.createTextNode(data); 上述语法格式中，data 是参数，包含了放在文本节点中的内容，是一个字符串。textNode 是返回值，表示创建的文本节点。 下面是使用 createTextNode() 方法的示例代码: var div = document.getElementById('group'); // 创建新的元素节点 var elem = document.createElement('button'); // 创建文本节点 var text = document.createTextNode('New Button'); // 将文本节点添加到新的元素节点 elem.appendChild(text); // 将新的元素节点添加到父级元素节点 div.appendChild(elem); 上述示例代码先通过 createElement() 方法创建了 button 元素，再通过 createTextNode() 方法创建了一个新的文本节点，并将其添加到新创建的 button 元素中。 创建属性节点 Document 对象提供了 createAtrribute() 方法创建属性节点，其语法格式如下: attributeNode = document.createAttribute(name); 上述语法格式中，name 是参数，属性节点的属性名称。attributeNode 是返回值，表示创建的属性节点。 值得注意的是: 创建属性节点方法只具有属性名称，没有属性值。想要设置属性值需要通过 nodeValue 属性完成。 由于属性节点不是元素节点的子节点，不能使用添加子节点方式操作属性节点。想要添加属性节点需要通过 setAttributeNode() 方法完成。 下面是使用 createAtrribute() 方法的示例代码: var div = document.getElementById('group'); // 创建新的元素节点 var elem = document.createElement('button'); // 创建文本节点 var text = document.createTextNode('New Button'); elem.appendChild(text); // 创建属性节点 var attribute = document.createAttribute('class'); // 设置属性的值 attribute.nodeValue = 'button'; // 将属性节点添加到元素节点 elem.setAttributeNode(attribute); div.appendChild(elem); 上述示例代码先通过 createAtrribute() 方法创建了 ，再通过 createTextNode() 方法创建了一个新的文本节点，并将其添加到新创建的 button 元素中。最后，通过 createAttribute() 方法创建 class 属性节点，并设置了属性值为 button，再将该属性节点添加到新创建的 button 元素中。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:15:22 "},"06-node-summary/":{"url":"06-node-summary/","title":"第一节 Node 对象介绍","keywords":"","body":"DOM 的标准规范中提供了 Node 对象，该对象主要提供了用于解析 DOM 节点树结构的属性和方法。 Node 对象的作用 DOM 树结构主要是依靠节点进行解析，称为 DOM 节点树结构。Node 对象是解析 DOM 节点树结构的主要入口。 Node 对象提供的属性和方法，可以实现遍历节点、插入节点和替换节点等操作。而这些操作也正是我们学习 Node 对象最为主要的目的。 Node 对象的继承链关系 Node 对象是继承于 EventTarget 对象的，EventTarget 是一个用于接收事件的对象。我们可以通过如下代码测试两者之间的继承关系: console.log(Node.prototype instanceof EventTarget); DOM 的标准规范中的 Document 对象和 Element 对象（后面的章节要学习的内容）都是继承于 Node 对象的。我们可以通过如下代码测试它们之间的继承关系: console.log(Document.prototype instanceof Node); console.log(Element.prototype instanceof Node); 测试 Node 对象 由于 Node 对象是 DOM 底层封装的对象，所以我们并不能通过直接打印 Node 对象来查看其属性或方法。 而是要通过打印 Node 对象的 prototype 原型属性来查看其属性或方法。 console.log(Node.prototype) 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:16:18 "},"07-node-type/":{"url":"07-node-type/","title":"第二节 判断节点类型","keywords":"","body":"Node 对象中提供了 nodeName、nodeType 和 nodeValue 分别可以用于获取指定节点的节点名称、节点类型和节点的值。 DOM 节点树结构中，我们实际开发最常见的节点有: 节点名称 含义 元素节点 表示 HTML 页面中的标签（即 HTML 页面的结构） 当访问 DOM 树时，需要从查找元素节点开始 属性节点 表示 HTML 页面中的开始标签包含的属性 文本节点 表示 HTML 页面中的标签所包含的文本内容 nodeName 属性 Node 对象的 nodeName 属性用于获取指定节点的节点名称。具体的语法结构如下: var str = node.nodeName; 在上述语法结构中，str 是一个存储了当前节点的节点名称的字符串。 值得注意的是: nodeName 是一个只读属性。 针对不同的节点类型，nodeName 返回的节点名称是不同的: 节点类型 nodeName 属性的值 Document 文档节点 \"#document\" Element 元素节点 元素节点的元素名 Attr 属性节点 属性节点的属性名 Text 文本节点 \"#text\" 如下代码示例，测试元素节点、属性节点和文本节点的 nodeName 的值: // 获取元素节点 var elemNode = document.getElementById('btn'); // 获取属性节点 var attrNode = elemNode.getAttributeNode('title'); // 获取文本节点 var textNode = elemNode.firstChild; console.log('元素节点的nodeName: ' + elemNode.nodeName); console.log('属性节点的nodeName: ' + attrNode.nodeName); console.log('文本节点的nodeName: ' + textNode.nodeName); nodeType 属性 Node 对象的 nodeType 属性用于获取指定节点的节点类型。具体的语法结构如下: var type = node.nodeType; 在上述语法结构中，type 是一个整数，其代表的是节点类型。 针对不同的节点类型，nodeType 返回的节点类型是不同的: 节点类型 nodeType 属性的值 Document 文档节点 9 Element 元素节点 1 Attr 属性节点 2 Text 文本节点 3 如下代码示例，测试元素节点、属性节点和文本节点的 nodeType 的值: // 获取元素节点 var elemNode = document.getElementById('btn'); // 获取属性节点 var attrNode = elemNode.getAttributeNode('title'); // 获取文本节点 var textNode = elemNode.firstChild; console.log('元素节点的nodeType: ' + elemNode.nodeType); console.log('属性节点的nodeType: ' + attrNode.nodeType); console.log('文本节点的nodeType: ' + textNode.nodeType); nodeValue 属性 Node 对象的 nodeValue 属性用于获取指定节点的节点值。具体的语法结构如下: var value = node.nodeValue; 在上述语法结构中，value 是一个包含当前节点的值的字符串。 针对不同的节点类型，nodeValue 返回的节点类型是不同的: 节点类型 nodeValue 属性的值 Document 文档节点 null Element 元素节点 null Attr 属性节点 属性节点的属性值 Text 文本节点 文本节点的内容 如下代码示例，测试元素节点、属性节点和文本节点的 nodeValue 的值: // 获取元素节点 var elemNode = document.getElementById('btn'); // 获取属性节点 var attrNode = elemNode.getAttributeNode('title'); // 获取文本节点 var textNode = elemNode.firstChild; console.log('元素节点的nodeValue: ' + elemNode.nodeValue); console.log('属性节点的nodeValue: ' + attrNode.nodeValue); console.log('文本节点的nodeValue: ' + textNode.nodeValue); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:17:59 "},"08-traverse-nodes/":{"url":"08-traverse-nodes/","title":"第三节 遍历节点","keywords":"","body":"遍历节点 Node 对象提供了一系列的属性和方法用来利用 DOM 节点树结构中节点的关系实现遍历其中的节点。 关于节点之间的关系，可以参考《DOM树结构》一节有关节点之间关系的内容。 获取父节点 通过 HTML 页面中指定元素查找其父级节点，我们可以使用 Node 对象的 parentNode 属性实现: pNode = node.parentNode; 在上述语法结构中，parentNode 属性返回指定节点的父节点。 值得注意的是: 一个元素节点的父节点，可能是一个元素节点，也可能是一个文档节点。 以下代码示例，就是通过 parentNode 属性获取指定节点的父节点，再实现其他操作的: var btn = document.getElementById('btn'); var parentNode = btn.parentNode; var className = parentNode.className; className += ' animate'; parentNode.className = className; 获取父元素节点 Node 对象除了提供了 parentNode 属性可以获取指定节点的父节点之外，还提供了 parentElement 属性获取指定节点的父元素节点。 parentElementNode = node.parentElement; 在上述语法结构中，parentElement 属性返回指定节点的父元素节点。 值得注意的是: 如果一个节点没有父节点，或者父节点不是一个元素节点的话，parentElement 属性返回 null。 以下代码示例，就是通过 parentElement 属性获取指定节点的父元素节点，再实现其他操作的: var btn = document.getElementById('btn'); var parentElement = btn.parentElement; var className = parentElement.className; className += ' animate'; parentElement.className = className; 父节点与父元素节点的区别 所谓父节点，并没有指定某个节点的父节点一定是哪个类型的节点。而父元素节点，指定了某个节点的父节点一定是元素节点。 parentNode: 获取指定节点的父节点，其父节点不一定是元素节点。 parentElement: 获取指定节点的父元素节点，其父节点必须是元素节点。 如果我们获取 元素的父节点的话，就是 document 文档节点。而 document 文档节点并不是一个元素节点。如下述代码示例: // 获取 元素 var html = document.documentElement; console.log('parentNode: ' + html.parentNode); console.log('parentElement: ' + html.parentElement); 上述代码示例，输出的结果如下: 获取子节点 通过 HTML 页面中指定元素查找其子节点，我们可以通过以下 Node 对象的属性实现: 属性名 描述 childNodes 获取指定节点的所有子节点 firstChild 获取指定节点的第一个子节点 lastChild 获取指定节点的最后一个子节点 值得注意的是: HTML 页面中某个元素的子节点不一定是唯一的。 获取所有子节点 Node 对象提供了 childNodes 属性用于获取 HTML 页面中指定节点的所有子节点: var ndList = Node.childNodes; 在上述语法结构中，childNodes 属性的返回值 ndList 是一个 NodeList 对象，并且为只读。该属性获取一个包含指定节点的所有子节点的集合。 值得注意的是: childNodes 属性返回的是一个动态的 NodeList 对象。有关动态 NodeList 的内容，请参考《定位页面元素》一节的内容。 以下代码示例，就是通过指定节点获取其所有子节点，再实现其他操作的: var parentNode = document.getElementById('parent'); var children = parentNode.childNodes; console.log(children); 上述代码示例，输出的结果如下: 我们会发现，获取到的所有子节点，除了真正的子节点 之外，还具有 4 个文本节点。 空白节点 主流浏览器解析 HTML 页面内容为 DOM 节点树结构时，会产生空文本的空白节点。这是由 HTML 页面源代码中的换行引起的: A Button A Button A Button 上述代码示例的 DOM 节点树结构如下图所示: 如果将 HTML 页面的源代码编写成一行时，这个空白节点的问题可以得到解决。但这种解决方式妨碍了我们代码的可读性，并不建议这样解决。 值得注意的是: IE 8 及之前版本的浏览器中不存在空白节点问题。 空白节点的解决方案 在开发中，空白节点的问题将 DOM 节点树结构的解析及操作增加了不少的难度和麻烦。我们这里提供一种比较简单有效的解决方式: 弃用 DOM 中 Node 对象用于获取指定节点的子节点和兄弟节点的属性。 通过使用 getElementsByTagName() 方法实现相应功能。 比如我们要查找 HTML 页面指定元素的所有子节点的话，我们按照如下代码示例实现: var parentNode = document.getElementById('parent'); var children = parentNode.getElementsByTagName('button'); console.log(children); 上述代码示例运行的结果如下: 关于 DOM 中为什么要具有空白节点以及更完整的解决方案，可以参考 Mozilla 社区的《DOM 中的空白符》。 获取第一个子节点 Node 对象提供了 firstChild 属性用于获取指定节点的第一个子节点: var first_child = node.firstChild; 在上述语法结构中，firstChild 属性返回的 first_child 表示当前节点的第一个子节点的引用。 值得注意的是: 如果当前节点无子节点，则 firstChild 属性返回 null。 以下代码示例，就是通过指定节点获取其第一个子节点，再实现其他操作的: var parentNode = document.getElementById('parent'); var firstChild = parentNode.firstChild; 通过上述代码示例，我们最终得到依旧是空白节点，而并非第一个子节点。 var parentNode = document.getElementById('parent'); var firstChild = parentNode.getElementsByTagName('button')[0]; console.log(firstChild); 通过 getElementsByTagName() 方法替换之后，所得到的节点才是真正的第一个节点。 获取最后一个节点 Node 对象提供了 lastChild 属性用于获取指定节点的最后一个子节点: var last_child = node.lastChild; 在上述语法结构中，lastChild 属性返回的 last_child 表示当前节点的最后一个子节点的引用。 值得注意的是: 如果当前节点无子节点，则 lastChild 属性返回 null。 以下代码示例，就是通过指定节点获取其最后一个子节点，再实现其他操作的: var parentNode = document.getElementById('parent'); var lastChild = parentNode.lastChild; 通过上述代码示例，我们最终得到依旧是空白节点，而并非最后一个子节点。 var parentNode = document.getElementById('parent'); var children = parentNode.getElementsByTagName('button'); var lastChild = children[children.length-1]; 通过 getElementsByTagName() 方法替换之后，所得到的节点才是真正的最后一个节点。 获取相邻兄弟节点 通过 HTML 页面中指定元素查找其相邻兄弟节点，我们可以通过以下 Node 对象的属性实现: 属性名 描述 previousSibling 获取指定节点的前面相邻兄弟节点 nextSibling 获取指定节点的后面相邻兄弟节点 获取相邻前面兄弟节点 Node 对象提供了 previousSibling 属性用于获取指定节点的前面相邻兄弟节点: previousNode = node.previousSibling; 在上述语法结构中，previousSibling 属性返回的 previousNode 表示当前节点的前一个兄弟节点。 值得注意的是: 如果当前节点无前一个兄弟节点，则 previousSibling 属性返回 null。 以下代码示例，就是通过指定节点获取其前面相邻兄弟节点，再实现其他操作的: var elem = document.getElementById('btn'); var previousSibling = elem.previousSibling; 通过上述代码示例，我们最终得到依旧是空白节点，而并非前面相邻兄弟节点。 // 判断获取的兄弟节点是否为元素节点 if ( previousSibling.nodeType != 1){ previousSibling = previousSibling.previousSibling; } 通过判断获取的节点类型是否为元素节点，实现如何获取真正的前面相邻兄弟节点。 获取相邻后面兄弟节点 Node 对象提供了 nextSibling 属性用于获取指定节点的后面相邻兄弟节点: nextNode = node.nextSibling; 在上述语法结构中，nextSibling 属性返回的 nextNode 表示当前节点的后一个兄弟节点。 值得注意的是: 如果当前节点无后一个兄弟节点，则 nextSibling 属性返回 null。 以下代码示例，就是通过指定节点获取其后面相邻兄弟节点，再实现其他操作的: var elem = document.getElementById('btn'); var nextSibling = elem.nextSibling; 通过上述代码示例，我们最终得到依旧是空白节点，而并非后面相邻兄弟节点。 // 判断获取的兄弟节点是否为元素节点 if ( nextSibling.nodeType != 1){ nextSibling = nextSibling.nextSibling; } 通过判断获取的节点类型是否为元素节点，实现如何获取真正的后面相邻兄弟节点。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 12:19:27 "},"09-insert-node/":{"url":"09-insert-node/","title":"第四节 插入节点","keywords":"","body":"Node 对象提供了一些用于向 HTML 页面插入节点的方法，通过这些方法我们可以实现向 HTML 页面新增元素，或者移动 HTML 页面中的元素。 appendChild() 方法 Node 对象提供的 appendChild() 方法可以向指定节点的子节点列表的最后添加一个新的子节点。其语法结构如下: var child = node.appendChild(child); 在上述语法结构中，appendChild() 方法的参数 child 表示添加的新的子节点，同时该子节点也是 appendChild() 方法的返回值。 我们可以通过如下代码示例，学习 appendChild() 方法的使用: var parent = document.getElementById('parent'); var button = document.createElement('button'); button.setAttribute('class','button'); var text = document.createTextNode('A New Button'); button.appendChild(text); // 将新节点添加到父节点中 parent.appendChild(button); 在上述代码示例中，我们创建了一个新的 元素，并且将这个 元素添加到指定节点的子节点列表的最后面。 值得注意的是: 如果我们是将 HTML 页面中原有的节点插入到指定节点的子节点列表的最后面，那这个被插入的节点会先从原有的位置移除，再插入到指定的位置。 如下代码示例，就是将 HTML 页面原有的节点插入到指定位置: var parent = document.getElementById('parent'); var button = document.getElementById('btn'); // 将新节点添加到父节点中 parent.appendChild(button); 值得注意的是: appendChild() 方法只能允许在同一个 HTML 页面中实现插入节点的功能，而不能实现跨 HTML 页面的插入节点的功能。 insertBefore() 方法 Node 对象除了提供了 appendChild() 方法可以实现插入节点之外，还提供了 insertBefore() 方法同样可以实现插入节点的功能。其语法结构如下: var insertedElement = parentElement.insertBefore(newElement, referenceElement); 由于 insertBefore() 方法实现的是将一个节点插入到指定节点的某个子节点的前面。所以，在上述语法结构中: 参数 referenceElement 表示指定节点的某个子节点 参数 newElement 表示插入的节点 调用 insertBefore() 方法的 parentElement 表示指定的节点 作为返回值的 insertedElement 表示被插入的节点，即 newElement 我们可以通过如下代码示例，学习 insertBefore() 方法的使用: // 获取目标父节点 var parentElement = document.getElementById('parent'); // 创建新节点 var newElement = document.createElement('button'); newElement.setAttribute('class','button'); var text = document.createTextNode('A New Button'); newElement.appendChild(text); // 获取目标节点 var referenceElement = document.getElementById('btn'); // 将新节点添加到父节点中 parentElement.insertBefore(newElement, referenceElement); 值得注意的是: 如果我们是将 HTML 页面中原有的节点插入到指定节点的某个子节点的前面，那这个被插入的节点会先从原有的位置移除，再插入到指定的位置。 如下代码示例，就是将 HTML 页面原有的节点插入到指定位置: // 获取目标父节点 var parentElement = document.getElementById('parent'); // 获取被插入的节点 var newElement = document.getElementById('button'); // 获取目标节点 var referenceElement = document.getElementById('btn'); // 将新节点添加到父节点中 parentElement.insertBefore(newElement, referenceElement); 值得注意的是: 如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。 关于 insertAfter() 方法 我们需要注意的是，Node 对象中并没有提供 insertAfter() 方法。所以，我们并不能像使用 jQuery 中的 insertAfter() 方法一样使用。 但是，如果我们在开发中需要 insertAfter() 方法的话，是可以利用 insertBefore() 方法来实现的。 实现思路其实就是利用 insertBefore() 方法将被插入的节点插入到指定节点的下一个相邻兄弟的前面，最终实现插入到指定节点的后面的效果。 parentElement.insertBefore(newElement, referenceElement.nextSibling); 但由于主流浏览器存在空白节点的问题，所以，在真正实现时不能简单地直接通过 nextSibling 属性来解决的。 最后，真正可以实现 insertAfter() 方法的主要逻辑如下: var nextElement = referenceElement.nextSibling; if(nextElement.nodeType === 3){ nextElement = nextElement.nextSibling; } parentElement.insertBefore(newElement, nextElement); 如果 referenceElement 没有下一个相邻的兄弟节点的话，那 referenceElement 一定是该子节点列表的最后一个子节点。这样 referenceElement.nextSibling 返回的值为 ull，newElement 就会被插入到子节点列表的最后面。 值得注意的是: 关于 insertAfter() 方法，我们这里只是提供了一个解决的思路。在具体使用时，可能封装的具体用法也会不同。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 13:04:25 "},"10-remove-node/":{"url":"10-remove-node/","title":"第五节 删除节点","keywords":"","body":"Node 对象提供了 removeChild() 方法实现从 HTML 页面中删除指定节点。其语法结构如下: var oldChild = node.removeChild(child); OR element.removeChild(child); 在上述语法结构中，调用 removeChild() 方法的 node 表示 child 参数的父节点，而 child 参数则表示要删除的那个节点。 oldChild 则用于存储要删除的节点的引用，即 oldChild === child。当然，如果我们需要完成的仅仅只是删除节点操作的话，并不需要定义变量来存储被删除的节点。 值得注意的是: 在上述语法结构中，如果 child 参数不是 node 的子节点的话，调用该方法时会报错。 我们可以通过如下代码示例，测试 removeChild() 方法的具体使用: // 获取父节点 var parent = document.getElementById('parent'); // 获取子节点 var child = document.getElementById('btn'); // 删除节点 parent.removeChild(child); 值得注意的是: 被删除的节点是否从内存中被销毁，Mozilla 社区有这样一段描述: 被移除的这个子节点仍然存在于内存中，只是没有添加到当前文档的 DOM 树中。 因此，你还可以把这个节点重新添加回文档中。当然，实现要用另外一个变量比如上述语法中的 oldChild 来保存这个节点的引用。 如果使用上述语法中的第二种方法，即没有使用 oldChild 来保存对这个节点的引用，则认为被移除的节点已经是无用的，在短时间内将会被内存管理回收。 根据 Mozilla 社区对 removeChild() 方法的描述，我们可以进行如下代码示例的尝试: // 获取父节点 var parent = document.getElementById('parent'); // 获取子节点 var child = document.getElementById('btn'); // 删除节点，并将删除的节点存储在 oldChild 变量中 var oldChild = parent.removeChild(child); // 将删除的节点再添加到父节点的子节点列表中 parent.appendChild(oldChild); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 13:05:06 "},"11-replace-node/":{"url":"11-replace-node/","title":"第六节 替换节点","keywords":"","body":"Node 对象提供了 replaceChild() 方法实现 HTML 页面中节点的替换功能。其语法结构如下: replacedNode = parentNode.replaceChild(newChild, oldChild); 在上述语法结构中，调用 replaceChild() 方法的 parentNode 表示被替换节点 oldChild 的父级节点。 参数 oldChild 则表示 HTML 页面中被替换的节点。replaceChild() 方法的返回值也是被替换的节点，即 oldChild == replaceNode。 参数 newChild 则表示用于替换的新节点。如果该节点已经存在于 DOM 节点树结构中的话，则它会被从原始位置删除。 我们可以通过如下代码示例，测试 replaceChild() 方法的具体使用: // 获取父节点 var parentNode = document.getElementById('parent'); // 创建新节点 var newChild = document.createElement('button'); newChild.setAttribute('class','button'); var text = document.createTextNode('A New Button'); newChild.appendChild(text); // 获取子节点 var oldChild = document.getElementById('btn'); // 替换节点 parentNode.replaceChild(newChild, oldChild); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 13:05:43 "},"12-clone-node/":{"url":"12-clone-node/","title":"第七节 复制节点","keywords":"","body":"Node 对象提供了 cloneNode() 方法实现 HTML 页面中节点的复制功能。其语法结构如下: var dupNode = node.cloneNode(deep); 在上述语法结构中，调用 cloneNode() 方法的 node 表示被克隆的节点，返回值 dupNode 表示克隆后的新节点。 参数 deep 则表示是否采用深度克隆。如果为 true，则该节点的所有后代节点也都会被克隆；如果为 false，则只克隆该节点本身。 值得注意的是: 参数 deep 如果默认不传递的话，值为 false。但在旧版本的浏览器中, 你始终需要指定 deep 参数。 我们可以通过如下代码示例，测试 replaceChild() 方法的具体使用: var parent = document.getElementById('parent'); var btn = document.getElementById('btn'); // 复制目标节点 var clone = btn.cloneNode(true); parent.appendChild(clone); 复制节点的注意事项 克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件，但不会拷贝那些使用 addEventListener() 方法或者 node.onclick = fn 这种用 JavaScript 动态绑定的事件。 在使用 Node.appendChild() 或其他类似的方法将拷贝的节点添加到文档中之前，那个拷贝节点并不属于当前文档树的一部分。也就是说，它没有父节点。 如果deep参数设为false，则不克隆它的任何子节点。该节点所包含的所有文本也不会被克隆，因为文本本身也是一个或多个的 Text 节点。 为了防止一个文档中出现两个 ID 重复的元素,使用 cloneNode() 方法克隆的节点在需要时应该指定另外一个与原 ID 值不同的 ID。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 13:06:22 "},"13-textcontent/":{"url":"13-textcontent/","title":"第八节 textContent 属性","keywords":"","body":"Node 对象提供了 textContent 属性实现获取或设置 HTML 页面中指定元素的文本内容。 获取文本内容 textContent 属性表示 HTML 页面指定节点及其后代节点的文本内容。其语法格式如下: var text = element.textContent; 在上述语法结构中，返回值 text 表示 element 节点及其后代节点的文本内容。 需要说明的是，在上述语法结构中，调用 textContent 属性的 element 表示元素节点。元素节点本身也是一个元素。 值得注意的是: 如果指定节点是 Document 文档节点的话，textContent 返回 null。 我们可以通过如下代码示例，测试如何通过 textContent 属性获取指定节点的文本内容: var pElement = document.getElementById('p'); console.log(pElement.textContent); 值得注意的是: 如果指定节点的后代节点也包含文本内容的话，那该节点调用 textContent 属性时，则会返回该节点及其所有后代节点的文本内容。 如下 HTML 页面结构: 这是一个段落内容。 如果我们通过上述 元素调用 textContent 属性的话，得到的结果并不是如下结果: 这是一个内容。 而是如下结果: 这是一个段落内容。 设置文本内容 通过 textContent 属性不仅可以获取 HTML 页面中指定节点及其后代节点的文本内容，还可以设置指定节点的文本内容。其语法结构如下: element.textContent = \"this is some sample text\"; 值得注意的是: 在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。 我们可以通过如下代码示例，测试如何通过 textContent 属性设置指定节点的文本内容: var btn = document.getElementById('btn'); btn.textContent = 'A New Button'; innerText 属性 IE 引入了 node.innerText 属性，意图类似 textContent。但有以下区别： textContent 会获取所有元素的内容，包括 和 元素，然而 innerText 不会。 innerText 意识到样式，并且不会返回隐藏元素的文本，而 textContent 会。 由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但 textContent 不会。 在 IE (小于等于 IE11 的版本) 中对 innerText 进行修改，不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点。 关于 innerText 属性的具体用法请参考 MSDN社区的相关说明.aspx)。 浏览器兼容问题解决方案 在实际开发中，我们需要尽量满足所有浏览器对文本内容操作的需求。所以，我们可以使用如下代码解决浏览器之间的兼容问题: function text(elem, text){ if(text){ elem.textContent ? elem.textContent = text : elem.innerText = text; }else{ if(elem.textContent){ // 表示其他浏览器 return elem.textContent; }else{ // 表示 IE 浏览器 return elem.innerText; } } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-19 13:07:14 "},"14-element-summary/":{"url":"14-element-summary/","title":"第一节 Element 对象介绍","keywords":"","body":"DOM 的标准规范中提供了 Element 对象，该对象提供了 HTML 页面中所有元素所具有的属性和方法。 我们都知道 DOM 标准规范中提供了 Node 对象，主要是依靠 DOM 节点树结构访问和更新 HTML 页面的内容。而 DOM 标准规范中提供了 Element 对象，主要是依靠 DOM 元素树结构访问和更新 HTML 页面的内容。 值得注意的是: 所有的 HTML 页面的元素都是 HTMLElement 对象，而这个对象又是继承于 Element 对象的。 Element 对象的作用 HTML 页面中的标签，既是元素节点，又是元素。 如果我们将 HTML 页面中的标签当做元素节点的话，就是利用 DOM 节点树结构进行解析和操作。但是，有些情况利用 Node 对象实现比较复杂，例如属性节点的操作，而使用 Element 对象提供的属性和方法相对会简单一些。 我们可以简单地理解 Element 对象是 Node 对象的补充。当然，这种理解并不准确！ 通过 Element 对象，我们可以实现遍历元素、属性操作等操作。而这些操作也正是我们要学习 Element 对象的属性和方法。 测试 Element 对象 由于 Element 对象是 DOM 底层封装的对象，所以我们并不能通过直接打印 Element 对象来查看其属性或方法。 而是要通过打印 Element 对象的 prototype 原型属性来查看其属性或方法。 console.log(Element.prototype) 运行 HTML 页面后，打开 开发者工具，我们可以看到以下内容: 上面运行后的结果只是部分内容，并不是全部内容。请自行测试！ Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-21 21:34:52 "},"15-element-tree/":{"url":"15-element-tree/","title":"第二节 DOM 元素树","keywords":"","body":"DOM 元素树结构与 DOM 节点树结构很相似，区别仅在于是利用节点解析 HTML 元素，还是利用元素解析 HTML 元素。 DOM 树结构 还记得下面这张图吗? 上图中的 HTML 页面源代码如下: 示例页面 这是一个示例页面 这是一个段落内容. DOM 之所以可以访问和更新 HTML 页面中的内容、结构和样式，是因为 DOM 将 HTML 页面解析为一个 树结构。 DOM 元素树 上述 HTML 页面示例代码，如果利用节点方式解析为 DOM 节点树结构 的话，如下所示: 如果利用元素方式解析为 DOM 元素树结构 的话，如下所示: 通过上图所示，我们发现 DOM 元素树结构与 DOM 节点树结构类似，同样在元素之间存在着某些固定的关系。 元素之间的关系 在 DOM 元素树结构中，主要具有以下三层关系。 父级与子级 如果我们将 HTML 页面中某一个元素作为父级的话，那包含在该元素内的第一层所有元素都可以称为该元素的子级。 例如，我们来看一下下面这个 DOM 元素树结构: 在上面的 DOM 节点树结构中， 元素作为父级， 和 元素作为子级。 祖先与后代 如果我们将 HTML 页面中某一个元素作为祖先的话，那包含在该元素内的所有元素（除子级之外的）都可以称为该元素的后代。 例如，我们来看一下下面这个 DOM 元素树结构: 在上面的 DOM 节点树结构中， 元素作为祖先，、、 和 元素作为后代。 兄弟关系 具有相同父级元素的两个或几个元素之间就是兄弟关系。例如，我们来看一下下面这个 DOM 元素树结构: 在上面的 DOM 元素树结构中， 和 元素就是兄弟关系。因为它们具有相同的父级元素 。 节点与元素的区别 利用节点解析 DOM 节点树结构时，我们会发现元素节点、属性节点和文本节点是独立存在的。 如果获取文本节点的话，文本节点是元素节点的子节点。所以，我们可以通过子节点方式得到指定的文本节点。 如果获取属性节点的话，由于属性节点不是元素节点的子节点。所以，并不能直接通过获取子节点的方式得到指定的属性节点。 而利用元素解析 DOM 元素树结构时，我们会发现元素、属性和文本是从属关系。什么意思呢? 我们可以简单地将属性和文本内容理解为是元素的一部分。 这样，我们获取属性或文本内容时，就可以通过元素的获取属性或获取文本内容的方法或属性来实现。 关于节点与元素的区别，我们可以通过以下示例代码来理解: // 节点方式获取属性节点 var btn = document.getElementById('btn'); var attrNode = btn.getAttributeNode('class'); var attrValue = attrNode.nodeValue; // 元素方式获取属性 var btn = document.getElementById('btn'); var attrValue = btn.getAttribute('class'); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-21 21:35:51 "},"16-location-element/":{"url":"16-location-element/","title":"第三节 定位页面元素","keywords":"","body":"Element 对象提供了属性和方法实现定位页面元素功能。该对象与 Document 对象提供的属性和方法实现定位页面元素功能的区别在于，Document 对象定位的是 HTML 页面中所有指定元素，而 Element 对象定位的是指定元素内所有指定元素。 定位页面元素方法 目前 Document 对象提供实现定位页面元素的方法具有如下几种: getElementsByTagName()方法：通过页面元素的元素名定位元素。 getElementsByClassName()方法：通过页面元素的 class 属性值定位元素。 querySelector()方法：通过 CSS 选择器定位第一个匹配的元素。 querySelectorAll()方法：通过 CSS 选择器定位所有匹配的元素。 接下来，我们就一一进行学习。 通过元素的元素名定位元素 其语法格式如下: elements = document.getElementsByTagName(name); 在上述语法中，name 是参数，表示所要定位元素的元素名，符号”*”表示所有元素。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByTagName() 方法的示例代码: var elems = document.getElementsByTagName('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByTagName() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 通过元素的 class 属性值定位元素 其语法格式如下: elements = document.getElementsByClassName(names); 在上述语法中，names 是参数，表示所要定位元素的 class 属性值列表，class 名称通过空格分隔。 值得注意的是: names 参数可以是一个样式属性名称，也可以是多个样式属性名称。 elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 getElementsByClassName() 方法的示例代码: var elems = document.getElementsByClassName('btn'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 getElementsByClassName() 方法定位 HTML 页面中 class 属性值为 btn 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 兼容 IE 8 及之前版本的浏览器 getElementsByClassName() 方法只支持 IE 9 版本及之后版本的浏览器。也就是说，该方法并不支持 IE 8 及之前版本的浏览器。 下图是不同浏览器的不同版本对 getElementsByClassName() 方法的支持情况: 由于国内的生产环境中，依旧存在使用 IE 8 及之前版本浏览器的情况。所以，我们需要自定义 getElementsByClassName() 方法解决浏览器的兼容问题。 function getElementsByClassName(element, names) { } 上述自定义兼容方法接受两个参数，element 参数表示调用 getElementsByClassName() 方法的对象（目前为 Document 对象），names 参数表示所要定位元素的 class 属性值列表。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 } } 这里我们要优先使用 W3C 规范的方法。所以，需要先判断当前浏览器环境是否存在 getElementsByClassName() 方法。 如果存在，就使用原本的 getElementsByClassName() 方法。如果不存在，就使用自定义代码来实现。 function getElementsByClassName(element, names) { // 检测 getElementsByClassName() 是否可用 if (element.getElementsByClassName) { // 优先使用 W3C 规范 return element.getElementsByClassName(names); }else { // 人为解决 IE 8 之前版本不兼容问题 // 获取所有后代元素节点 var elements = element.getElementsByTagName('*'); // 定义空数组 var result = []; var element, classNameStr, flag; // 将样式名称改为数组类型 names = names.split(' '); // 循环遍历所有元素节点 for (var i=0; element = elements[i]; i++) { // 获取每个元素节点的样式名称 classNameStr = ' ' + element.className + ' '; // 开启开关 flag = true; // 循环遍历所有的样式名称 for (var j=0, name; name = names[j]; j++) { // 判断当前元素节点的样式名称中是否包含指定的样式名称 if (classNameStr.indexOf(' ' + name + ' ') == -1){ // 如果不包含，则关闭开关，并且结束循环 flag = false; break; } } // 判断当前元素节点是否包含指定样式名称 if (flag) { // 如果包含，则将当前元素节点添加到数组中 result.push(element); } } // 返回数组(所有包含指定样式名称的元素节点) return result; } } 通过 CSS 选择器定位元素 CSS 中的选择器可以很便利地定位 HTML 页面元素，DOM 的标准规范中也提供类似的方法。 querySelector(): 定位匹配选择器的第一个元素。 querySelectorAll(): 定位匹配选择器的所有元素。 querySelector() 方法 其语法格式如下: element = document.querySelector(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。element 是返回值，表示定位元素的集合，匹配的第一个元素。 下面是使用 querySelector() 方法的示例代码: var btn = document.querySelector(’#btn'); // 获取定位元素的 class 属性值 var className = btn.className; // 添加 animate 动画样式 className += ' animate'; // 将新的 class 属性值设置 btn.className = className; 上述代码通过 querySelector() 方法定位 HTML 页面中 id 属性值为 btn 的元素，并为其元素的 class 属性添加 animate 样式。 querySelectorAll() 方法 其语法格式如下: elements = document.querySelectorAll(selectors); 在上述语法中，selectors 是参数，表示选择器，可以包含一个或多个 CSS 选择器，多个则以逗号分隔。elements 是返回值，表示定位元素的集合，是一个 NodeList 集合。 下面是使用 querySelectorAll() 方法的示例代码: var elems = document.querySelectorAll('button'); // 循环遍历所有元素 for (var i=0; i 上述代码通过 querySelectorAll() 方法定位 HTML 页面中元素名为 button 的元素，并遍历所有得到的元素，为其元素的 class 属性添加 animate 样式。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-21 21:43:11 "},"17-traverse-elements/":{"url":"17-traverse-elements/","title":"第四节 遍历元素","keywords":"","body":"Element 对象提供了一系列的属性和方法用来利用 DOM 元素树结构中元素的关系实现遍历其中的元素。 关于元素之间的关系，可以参考《DOM 元素树》一节有关元素之间关系的内容。 获取子元素 通过 HTML 页面中指定元素查找其子元素，我们可以通过以下 Element 对象的属性实现: 属性名 描述 children 获取指定元素的所有子元素 firstElementChild 获取指定元素的第一个子元素 lastElementChild 获取指定元素的最后一个子元素 值得注意的是: HTML 页面中某个元素的子元素不一定是唯一的。 获取所有子元素 Element 对象提供了 children 属性用于获取 HTML 页面中指定节点的所有子元素: var elList = element.children; 在上述语法结构中，children 属性的返回值 elList 是一个 HTMLCollection 对象，并且为只读。该属性获取一个包含指定元素的所有子元素的集合。 以下代码示例，就是通过指定元素获取其所有子元素，再实现其他操作的: var parentElem = document.getElementById('parent'); var children = parentElem.children; console.log(children); 获取所有子元素的个数 Element 对象提供了 childElementCount 属性用于获取指定元素的所有子元素的个数: var count = element.childElementCount; 在上述语法结构中，childElementCount 属性返回的 count 表示指定元素的所有子元素的个数。 以下代码示例，就是通过指定元素获取其所有子元素的个数，再实现其他操作的: var parentElem = document.getElementById('parent'); var count = parentElem.childElementCount; console.log(count); 获取第一个子元素 Element 对象提供了 firstElementChild 属性用于获取指定元素的第一个子元素: var first_child = element.firstElementChild; 在上述语法结构中，firstElementChild 属性返回的 first_child 表示当前元素的第一个子元素的引用。 值得注意的是: 如果当前元素无子节点，则 firstElementChild 属性返回 null。 以下代码示例，就是通过指定元素获取其第一个子元素，再实现其他操作的: var parentElem = document.getElementById('parent'); var firstChild = parentElem.firstElementChild; console.log(firstChild); 获取最后一个元素 Element 对象提供了 lastElementChild 属性用于获取指定元素的最后一个子元素: var last_child = node.lastElementChild; 在上述语法结构中，lastElementChild 属性返回的 last_child 表示当前元素的最后一个子元素的引用。 值得注意的是: 如果当前节点无子元素，则 lastElementChild 属性返回 null。 以下代码示例，就是通过指定元素获取其最后一个子元素，再实现其他操作的: var parentElem = document.getElementById('parent'); var lastChild = parentElem.lastElementChild; console.log(lastChild); 获取相邻兄弟元素 通过 HTML 页面中指定元素查找其相邻兄弟元素，我们可以通过以下 Element 对象的属性实现: 属性名 描述 previousElementSibling 获取指定元素的前面相邻兄弟元素 nextElementSibling 获取指定元素的后面相邻兄弟元素 获取相邻前面兄弟元素 Element 对象提供了 previousElementSibling 属性用于获取指定元素的前面相邻兄弟元素: previousElem = element.previousElementSibling; 在上述语法结构中，previousElementSibling 属性返回的 previousElem 表示当前元素的前一个兄弟元素。 值得注意的是: 如果当前节点无前一个兄弟元素，则 previousElementSibling 属性返回 null。 以下代码示例，就是通过指定元素获取其前面相邻兄弟元素，再实现其他操作的: var btn = document.getElementById('btn'); var previousElem = btn.previousElementSibling; console.log(previousElem); 获取相邻后面兄弟元素 Element 对象提供了 nextElementSibling 属性用于获取指定元素的后面相邻兄弟元素: nextElem = element.nextElementSibling; 在上述语法结构中，nextElementSibling 属性返回的 nextElem 表示当前元素的后一个兄弟元素。 值得注意的是: 如果当前节点无后一个兄弟元素，则 nextElementSibling 属性返回 null。 以下代码示例，就是通过指定元素获取其后面相邻兄弟元素，再实现其他操作的: var btn = document.getElementById('btn'); var nextElem = btn.nextElementSibling; console.log(nextElem); 浏览器兼容问题 上述 Element 对象的遍历元素属性中，除 children 外，其他属性均不支持 IE 8 及之前版本的浏览器: childElementCount firstElementChild lastElementChild previousElementSibling nextElementSbling 浏览器兼容问题解决方案 我们可以通过自定义 JavaScript 文件方式，实现浏览器兼容问题。如以下代码示例: /** * Adds support to IE8 for the following properties: * * Element.childElementCount * Element.firstElementChild * Element.lastElementChild * Element.nextElementSibling * Element.previousElementSibling */ (function(){ \"use strict\"; var patches = { firstElementChild: function(){ for(var nodes = this.children, n, i = 0, l = nodes.length; i = 0; --i) if(n = nodes[i], 1 === n.nodeType) return n; return null; }, nextElementSibling: function(){ var e = this.nextSibling; while(e && 1 !== e.nodeType) e = e.nextSibling; return e; }, previousElementSibling: function(){ var e = this.previousSibling; while(e && 1 !== e.nodeType) e = e.previousSibling; return e; }, childElementCount: function(){ for(var c = 0, nodes = this.children, n, i = 0, l = nodes.length; i 需要说明的是: 上述浏览器兼容问题的解决方案是由 Snippets 开源项目提供的。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-21 21:44:17 "},"18-attributes-operate/":{"url":"18-attributes-operate/","title":"第五节 属性操作","keywords":"","body":"Element 对象提供了一些方法实现 HTML 元素的属性操作，这种操作要比 Node 对象提供的方法操作属性节点要更便捷。 获取指定元素的属性 Element 对象提供了 getAttribute() 方法用于获取指定元素的属性值，其语法结构如下: var attribute = element.getAttribute(attributeName); 在上述语法结构中，调用 getAttribute() 方法的 element 表示指定的元素，传递的参数 attributeName 则表示指定的属性名，得到的是指定属性对应的值。 值得注意的是: 如果指定的属性不存在，则返回 null 或 \"\" （空字符串）。 我们可以通过以下示例代码，学习 getAttribute() 方法的具体使用: var btn = document.getElementById('btn'); var className = btn.getAttribute('class'); console.log(className); 设置指定元素的属性 Element 对象提供了 setAttribute() 方法用于设置指定元素的属性值，其语法结构如下: element.setAttribute(name, value); 在上述语法结构中，调用 setAttribute() 方法的 element 表示指定的元素，传递的参数 name 表示设置指定的属性名，value 表示设置指定属性的值。 值得注意的是: 如果该属性已经存在，则更新该值; 否则将添加一个新的属性用指定的名称和值。 我们可以通过以下示例代码，学习 setAttribute() 方法的具体使用: var btn = document.getElementById('btn'); var className = btn.getAttribute('class'); className += ' animate'; btn.setAttribute('class',className); 删除指定元素的属性 Element 对象提供了 removeAttribute() 方法用于删除指定元素的属性，其语法结构如下: element.removeAttribute(attrName); 在上述语法结构中，调用 removeAttribute() 方法的 element 表示指定的元素，传递的参数 attrName 则表示删除的属性名。 值得注意的是: 删除属性尽量使用 removeAttribute() 方法，而不是调用 setAttribute() 方法将指定属性的值设置为 null。 如果删除的属性不存在的话，不会引发任何异常。 我们可以通过以下示例代码，学习 removeAttribute() 方法的具体使用: var btn = document.getElementById('btn'); btn.removeAttribute('class'); 判断是否含有指定属性 Element 对象提供了 hasAttribute() 方法用于判断是否含有指定的属性，其语法结构如下: var result = element.hasAttribute(attrName); 在上述语法结构中，调用 hasAttribute() 方法的 element 表示指定的元素，传递的参数 attrName 则表示要判断的属性名。 而 result 则是 hasAttribute() 方法的返回值，是一个 Boolean 类型的值。如果结果为 true，则表示含有指定的属性；如果结果为 false，则表示不含有指定的属性。 我们可以通过以下示例代码，学习 hasAttribute() 方法的具体使用: var btn = document.getElementById('btn'); var result = btn.hasAttribute('class'); console.log(result); 判断是否含有属性 Element 对象提供了与 hasAttribute() 方法相似的 hasAttributes() 方法用于判断是否含有属性，其语法结构如下: var result = element.hasAttributes(); 在上述语法结构中，调用 hasAttribute() 方法的 element 表示指定的元素，result 则是 hasAttributes() 方法的返回值，是一个 Boolean 类型的值。 值得注意的是: 该方法在某些浏览器中，已被废弃。 我们可以通过以下示例代码，学习 hasAttributes() 方法的具体使用: var btn = document.getElementById('btn'); var result = btn.hasAttributes(); console.log(result); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-21 21:45:43 "},"19-innerhtml/":{"url":"19-innerhtml/","title":"第六节 innerHTML 属性","keywords":"","body":"Element 对象提供了 innerHTML 属性用于实现获取或设置 HTML 页面指定元素的 HTML 代码。 获取 HTML 代码 innerHTML 属性表示 HTML 页面指定元素后代的 HTML 代码，其语法结构如下: var content = element.innerHTML; 在上述语法结构中，作为返回值 content 表示描述元素后代的 HTML 语句。 需要说明的是，在上述语法结构中，调用 innerHTML 属性的 element 表示元素节点。元素节点本身也是一个元素。 我们可以通过以下示例代码，学习如何通过 innerHTML 属性获取指定元素的 HTML 语句: var parent = document.getElementById('parent'); var content = parent.innerHTML; console.log(content); 设置 HTML 代码 innerHTML 属性不仅提供了获取 HTML 页面中指定元素的后代 HTML 语句，还提供了设置 HTML 页面中指定元素的后代 HTML 语句。其语法结构如下: element.innerHTML = markup; 在上述语法结构中，markup 表示设置描述元素后代的 HTML 语句。 我们可以通过以下示例代码，学习如何通过 innerHTML 属性设置指定元素的 HTML 语句: var parent = document.getElementById('parent'); parent.innerHTML = 'A Button'; 不是 W3C 规范 尽管 innerHTML 属性不属于 W3C DOM 规范，但是它为完全替换元素内容提供了一个更加便捷的方式。 举个例子，可以通过如下代码完全删除文档内body的内容: document.body.innerHTML = \"\"; 值得注意的是: 因为 innerHTML 属性没有统一的标准，各浏览器厂商对它实现差别很大。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-08-21 21:46:43 "},"20-get-inline-style/":{"url":"20-get-inline-style/","title":"第一节 获取内联样式","keywords":"","body":"回顾什么是内联样式 所谓内联样式，就是通过 HTML 页面元素的 style 属性为当前元素定义 CSS 样式。 以下代码示例，就是通过 style 属性定义 CSS 内联样式: 这是一个段落内容. 值得注意的是: HTML 页面的结构与样式并没有有效分离 定义的 CSS 样式只针对当前元素有效 获取内联样式 由于设置内联样式的方式是利用 HTML 页面元素的 style 属性实现的，所以获取内联样式主要是依靠 DOM 中获取属性方式实现。 Element 对象的 getAttribute() 方法获取 style 属性的值。 通过 DOM 对象 HTMLElement 的 style 属性获取。 Element 对象的 getAttribute() 方法 Element 对象的 getAttribute() 方法的语法结构如下: var value = element.getAttribute('style'); 以上语法结构中调用 getAttribute() 方法的 element 表示 HTML 页面元素，传递的参数 style 表示属性名称，而返回值则是指定属性名对应的值（内联样式的声明内容）。 我们可以通过以下示例代码，学习如何通过 getAttribute() 方法获取内联样式: 这是一个段落内容. var pElem = document.getElementById('p1'); var style = pElem.getAttribute('style'); console.log(style); 上述示例代码的输出结果如下: DOM 对象的 style 属性 由于 DOM 规范标准中将 Document 对象定位的 HTML 页面元素解析为相应的对象，而这些对象都继承于 HTMLElement 对象。该对象提供了 style 属性，返回 CSSStyleDeclaration 对象。 我们可以通过以下示例代码，学习如何通过 HTMLElement 对象的 style 属性获取内联样式: 这是一个段落内容. var pElem = document.getElementById('p1'); var style = pElem.style; console.log(style); 上述示例代码，通过 style 属性会得到 CSSStyleDeclaration 对象，该对象表示一个 CSS 属性键值对的集合。 CSSStyleDeclaration 对象 通过 element.style 返回的是 CSSStyleDeclaration 对象。CSSStyleDeclaration 对象表示一个CSS属性键值对的集合。 CSSStyleDeclaration 对象提供的属性和方法可以帮助我们获取 CSS 样式的具体内容。 属性或方法 描述 cssText 声明块的文本内容。 length 属性的数量。 item() 返回属性名。 例如: nameString= styleObj.item(0) Alternative: nameString= styleObj[0] getPropertyValue() 返回属性值。例如: valString= styleObj.getPropertyValue('color') cssText 属性 通过 element.style.cssText 属性获取 CSS 声明块的文本内容。 我们可以通过以下示例代码，学习如何通过 cssText 属性获取 CSS 声明块的文本内容: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; var cssText = styleDeclar.cssText; console.log(cssText); 上述示例代码的输出结果如下: 值得注意的是: cssText 属性返回的是 CSS 声明块的文本内容，解析操作时会比较麻烦。 遍历 CSSStyleDeclaration 对象 由于 CSSStyleDeclaration 对象具有 length 属性，返回该对象的属性的数量。我们可以通过这一特性实现遍历 CSSStyleDeclaration 对象，从而得到所有属性名和相应的值。 我们可以通过以下示例代码，学习如何遍历 CSSStyleDeclaration 对象: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; for ( var i=0; i 上述示例代码的输出结果如下: 在上述示例代码中，我们利用 CSSStyleDeclaration 对象的 length 属性控制遍历过程。 在遍历过程中，我们先利用 CSSStyleDeclaration 对象的 item() 方法得到每一个 CSSStyleDeclaration 对象的属性名，再利用 CSSStyleDeclaration 对象的 getPropertyValue() 方法根据属性名得到相应的值。 item() 方法 通过 element.style.item(index) 获取 CSS 的样式属性名，这种方式也可以通过 element.style[index] 方式进行替换。换句话讲，这两种方式是等价的。 我们可以通过以下示例代码，学习对比这两种方式: for ( var i=0; i 上述示例代码的输出结果如下: getPropertyValue() 方法 通过 element.style.item.getPropertyValue() 获取 CSS 的样式属性值，这种方式也可以通过 element.style[propertyName] 方式进行替换。 我们可以通过以下示例代码，学习对比这两种方式: for ( var i=0; i 上述示例代码的输出结果如下: 属性链方式操作 由于通过 element.style 返回的是 CSSStyleDeclaration 对象，所以我们也可以通过 element.style.attrName 的方式获取具体的样式属性的值。 我们可以通过以下示例代码，学习这种获取方式: 这是一个段落内容. var pElem = document.getElementById('p1'); var style = pElem.style; console.log(style.color); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-09-19 22:10:20 "},"21-get-external-style/":{"url":"21-get-external-style/","title":"第二节 获取外联样式表","keywords":"","body":"回顾什么是外联样式 所谓外联样式，就是在 HTML 页面中内嵌样式表或者引入外部样式文件，再通过 CSS 选择器定位 HTML 页面元素，为其定义样式。 以下示例代码，就是定义外联样式表: 上述示例代码，通过 元素引入外部的样式表。 .button { background-color: orange; } 上述示例代码，通过 元素定义内嵌样式表。 Document 对象的 styleSheets 属性 Document 对象提供了 styleSheets 属性，该属性返回包含所有外联样式表（内嵌样式表和外联样式表）的集合对象。 var styleSheetList = document.styleSheets; 上述语法结构中，作为返回值的 styleSheetList 是一个由 styleSheet 对象组成的列表，每个 styleSheet 对象表示 HTML 页面中内嵌样式表或外联样式表。 我们可以通过打印该属性值进行测试: console.log(document.styleSheets); 上述示例代码输出的结果如下: StyleSheetList 对象 Document 对象的 styleSheets 属性返回的是一个 StyleSheetList 对象。该对象是一个类数组对象，可以通过 for 循环语句进行遍历，或者将其转换为数组。 值得注意的是: StyleSheetList 对象本身不能使用数组方法进行操作。 我们可以通过以下示例代码，测试研究 StyleSheetList 对象: var styleSheetList = document.styleSheets; for (var i=0; i 上述示例代码中，每次循环得到的是 StyleSheet 对象。 CSSStyleSheet 对象 CSSStyleSheet 对象表示一个 CSS 样式表（内嵌样式表或外联样式表）。CSSStyleSheet 实现了更为通用的 StyleSheet，也从其父级 StyleSheet 继承了属性和方法。 我们可以通过打印该对象进行测试: console.log(document.styleSheets[0]); 上述示例代码输出的结果如下: CSSRuleList 对象 CSSStyleSheet 对象的 cssRules 属性返回的是一个 CSSRuleList 对象。该对象是一个类数组对象，可以通过 for 循环语句进行遍历，或者将其转换为数组。 我们可以通过以下示例代码，测试研究 CSSRuleList 对象: var styleSheet = document.styleSheets[0]; var cssRuleList = styleSheet.cssRules; for(var i=0; i 上述示例代码中，每次循环得到是 CSSRule 对象。 CSSRule 对象 CSSRule 对象表示一个 CSS 规则。一个 CSS 样式表包含了一组 CSS 规则。 CSSRule 对象的常见属性： style：返回 CSSStyleDeclaration 对象 cssText：CSS 规则 selectorText：选择器 我们可以通过以下示例代码，测试研究 CSSRule 对象: console.log(document.styleSheets[1].cssRules[0]); 上述示例代码输出的结果如下: Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-09-19 22:05:59 "},"22-get-class-attr/":{"url":"22-get-class-attr/","title":"第三节 获取 class 属性","keywords":"","body":"类选择器设置 CSS 样式 通过 CSS 的类选择器为 HTML 页面中的元素定义 CSS 样式，是我们开发中比较常见的一种方式。 我们也可以通过 HTML 页面元素 class 属性获取其对应的 CSS 样式。 .button { background-color: orange; } Element 对象的 className 属性 Element 对象提供了 className 属性用于获取 HTML 页面中指定元素的 class 属性值。 值得注意的是: Element 对象提供的是 className 属性，并不是 class 属性。原因是 class 在 JavaScript 中是关键字。 className 属性的的语法结构如下: var cName = elementNodeReference.className; 上述语法结构中，className 属性返回值 cName 表示一个字符串变量。表示当前元素的class属性的值，可以是由空格分隔的多个class属性值。 我们可以通过以下示例代码，学习 className 属性的使用: var btn = document.getElementById('btn'); console.log(btn.className); 上述示例代码输出的结果如下: Element 对象的 classList 属性 Element 对象的 className 属性虽然可以获取 HTML 页面中指定元素的 class 属性值，但返回值的是字符串类型。如果 HTML 页面中指定元素的 class 属性值为多个样式的话，对于我们操作会比较麻烦。 Element 对象还提供了 classList 属性，该属性可以获取 HTML 页面指定元素的 class 属性值的列表。其语法结构如下: var elementClasses = elementNodeReference.classList; 上述语法结构中，classList 属性返回值 elementClasses 表示HTML 页面元素的 class 属性值所组成的列表。 我们可以通过以下示例代码，学习 classList 属性的使用: var btn = document.getElementById('btn'); var elemClasses = btn.classList; for(var i=0; i 上述示例代码输出的结果如下: 浏览器兼容问题 Element 对象的 classList 属性，在 IE 8 及之前版本的浏览器中并不支持。所以，我们要想在各个浏览器中都支持该属性。 需要在 HTML 页面中引入以下 JavaScript 文件: /* * classList.js: Cross-browser full element.classList implementation. * 1.1.20170427 * * By Eli Grey, http://eligrey.com * License: Dedicated to the public domain. * See https://github.com/eligrey/classList.js/blob/master/LICENSE.md */ /*global self, document, DOMException */ /*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */ if (\"document\" in self) { // Full polyfill for browsers with no classList support // Including IE 该文件的下载地址为: https://github.com/eligrey/classList.js/blob/master/classList.js Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-09-19 22:08:35 "},"23-get-computed-style/":{"url":"23-get-computed-style/","title":"第四节 获取当前有效样式","keywords":"","body":"CSS 样式的优先级别 为 HTML 页面中的元素通过多种方式定义 CSS 样式。这些定义 CSS 样式方式的优先级别各不相同： 内联样式的优先级别最高 ID 选择器和伪类 类选择器和属性选择器 元素选择器和伪元素 通配符选择器和组合选择器 !important 将当前选择器的优先级别设置为最高 通过 DOM 操作 HTML 页面中指定元素的样式时，只需要获取其运行时的有效样式即可。 getComputedStyle() 方法 Window 对象中提供了 getComputedStyle() 方法，用于获取指定元素的当前有效样式，得到 CSSStyleDeclaration 对象。 其语法结构如下: var style = window.getComputedStyle(element, [pseudoElt]); 上述语法结构中，向 getComputedStyle() 方法传递的 element 参数表示获取有效样式的指定元素。而 pseudoElt 参数是个可选项，指定一个要匹配的伪元素的字符串。 值得注意的是: pseudoElt 参数必须对普通元素省略（或 null）。 getComputedStyle() 方法的返回值是 CSSStyleDeclaration 对象，表示指定元素的有效样式。 我们可以通过以下示例代码，学习 getComputedStyle() 方法的使用方式: var btn = document.getElementById('btn'); var style = window.getComputedStyle(btn, null); console.log(style.backgroundColor); currentStyle 属性 由于 getComputedStyle() 方法在 IE 8 及之前版本的浏览器中并不支持。所以，如果想要在 IE 8 及之前版本的浏览器中实现相同功能的话，需要使用 currentStyle 属性。 var btn = document.getElementById('btn'); var style = btn.currentStyle; console.log(style.backgroundColor); 通过 element.currentStyle 属性得到 currentStyle 对象，该对象提供了有关 CSS 样式表的所有样式属性。 浏览器兼容问题解决方案 在实际开发中，我们需要既支持 IE 8 及之前版本的浏览器，也需要支持其他浏览器。所以，我们可以编写如下代码，解决浏览器的兼容问题: function getStyle(elem, attrName){ // 判断 window.getComputedStyle() 方法是否存在 if (window.getComputedStyle){ return getComputedStyle(elem, null); }else{ return elem.currentStyle[attrName]; } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-09-19 22:09:10 "},"24-set-inline-style/":{"url":"24-set-inline-style/","title":"第五节 设置内联样式","keywords":"","body":"设置内联样式与获取类似，都是通过 style 属性或 setAttribute() 方法实现。 style 属性方式 设置内联样式，依旧是通过 HTML 页面元素的 style 属性实现。 具体语法结构如下: element.style = style; 我们可以通过以下示例代码，学习如何通过 style 属性设置内联样式: 这是一个段落内容. var pElem = document.getElementById('p1'); pElem.style = 'color: lightblue;font-weight: lighter'; 值得注意的是: 这种方式定义 CSS 样式，是字符串类型。并不适用于定义过多的 CSS 样式属性。 setAttirbute() 方法方式 通过 style 属性设置内联样式，我们还可以调用 element.setAttribute() 方法实现。 这是一个段落内容. var pElem = document.getElementById('p1'); // 通过 element.setAttribute() 方法设置样式 pElem.setAttribute('style','color: lightblue;font-weight: lighter'); // 通过 element.removeAttribute() 方法删除样式 pElem.removeAttribute('style'); 值得注意的是: 通过 setAttribute() 方法设置内联样式同样是字符串类型。 CSSStyleDeclaration 对象 通过 style 属性获取内联样式的学习，我们知道 style 属性返回的是 CSSStyleDeclaration 对象。该对象封装了 CSS 中的所有样式属性，所以我们也可以通过该对象设置内联样式。 CSSStyleDeclaration 对象提供的属性和方法可以帮助我们设置 CSS 样式的具体内容。 属性或方法 描述 setProperty() 为指定的 CSS 样式属性设置一个新的值。 removeProperty() 删除指定的 CSS 样式属性。 setProperty() 方法 CSSStyleDeclaration 对象提供的 setProperty() 方法，用于设置指定的 CSS 样式属性。其语法结构如下: style.setProperty(propertyName, value, priority); 上述语法结构中，作为参数的 propertyName 表示要修改的 CSS 样式属性名称。 value 是可选的，表示为修改的 CSS 样式属性新的值。如果没有设置任何值，则表示空字符串。 参数 priority 也是可选的，表示设置 CSS 样式的优先级别。 我们可以通过以下示例代码，学习如何通过 setProperty() 方法设置 CSS 的样式属性: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; styleDeclar.setProperty('color','lightblue'); removeProperty() 方法 CSSStyleDeclaration 对象提供的 removeProperty() 方法，用于删除指定的 CSS 样式属性。其语法结构如下: var oldValue = style.removeProperty(property); 上述语法结构中，作为参数的 property 表示要删除的 CSS 样式属性名称，作为返回值的 oldValue 表示删除的样式属性的值。 我们可以通过以下示例代码，学习如何通过 removeProperty() 方法删除 CSS 的样式属性: 这是一个段落内容. var pElem = document.getElementById('p1'); var styleDeclar = pElem.style; styleDeclar.removeProperty('font-weight'); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-09-19 22:09:57 "},"25-set-class-attr/":{"url":"25-set-class-attr/","title":"第六节 设置 class 属性","keywords":"","body":"设置 class 属性与获取 class 属性方式类似，都是通过 Element 对象提供的 className 属性和 classList 属性实现。 Element 对象的 className 属性 Element 对象提供的 className 属性既可以实现获取，也可以实现设置。其设置的语法结构如下: elementNodeReference.className = cName; 上述语法结构中，作为值的 cName 是一个字符串变量。表示当前元素的class属性的值，可以是由空格分隔的多个class属性值。 我们可以通过以下示例代码，学习如何通过 className 属性设置: var btn = document.getElementById('btn'); var className = btn.className; className += ' animate'; btn.className = className; Element 对象的 classList 属性 Element 对象提供的 classList 属性与 className 属性类似，既可以实现获取，也可以实现设置。 但 classList 属性自身是只读属性，换句话讲，我们并不能通过 classList 属性进行设置。而是通过以下方法实现: 方法名称 描述 add() 添加指定的类值。如果这些类已经存在于元素的属性中，那么它们将被忽略。 remove() 删除指定的类值。 item() 按集合中的索引返回类值。 toggle() 切换指定的类值。 contains() 检查元素的类属性中是否存在指定的类值。 我们可以通过以下示例代码，学习上述方法的使用: var btn = document.getElementById('btn'); var classList = btn.classList; // 添加 .animate 样式 classList.add('animate'); // 删除 .animate 样式 classList.remove('animate'); // 如果 .animate 存在，则删除；如果 .animate 不存在，则添加 classList.toggle('animate'); // 判断是否存在 .animate 样式 console.log(classList.contains('animate')); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-09-19 22:11:24 "},"26-element-style-attr/":{"url":"26-element-style-attr/","title":"第七节 Element 对象的样式属性","keywords":"","body":"Element 对象提供一系列有关样式的属性: clientHeight 和 clientWidth 属性 scrollHeight 和 scrollWidth 属性 scrollTop 和 scrollLeft 属性 继承于 Element 对象的 HTMLElement 对象同样提供一系列有关样式的属性: offsetParent 属性 offsetHeight 和 offsetWidth 属性 offsetTop 和 offsetLeft 属性 元素内部的宽度和高度 Element 对象的 clientWidth 和 clientHeight 属性表示元素内部的宽度和高度，单位为像素。这些属性的值包含内边距，但不包含滚动条、边框和外边距。 我们也可以通过以下方式计算 clientWidth 和 clientHeight 属性: clientWidth = CSS 的 width + CSS 的 padding – 滚动条的宽度（如果存在的话） clientHeight = CSS 的 height + CSS 的 padding – 滚动条的高度（如果存在的话） 我们可以通过以下示例代码，学习测试 clientWidth 和 clientHeight 属性: var div = document.getElementById('d'); // 获取 div 的样式 var style = document.styleSheets[0].cssRules[0].style; // 计算 clientWidth 属性的值 var clientWidth = parseInt(style.width) + parseInt(style.paddingLeft) + parseInt(style.paddingRight); // 测试打印 clientWidth = width + padding-left + padding-right console.log(div.clientWidth, clientWidth); 内容区的宽度和高度 Element 对象的 scrollWidth 属性表示元素内容的宽度，单位为像素。 scrollWidth 属性返回元素内容区的宽度和元素本身宽度中更大的那个值。 Element 对象的 scrollHeight 属性表示元素内容的高度，单位为像素。scrollHeight 属性包含 overflow 样式属性导致不可见的内容区。 我们可以通过以下示例代码，学习测试 scrollWidth 和 scrollHeight 属性: var div1 = document.getElementById('d1'); console.log(div1.scrollWidth); var div2 = document.getElementById('d2'); console.log(div2.scrollHeight); 滚动条滚动的宽度和高度 Element 对象的 scrollLeft 属性表示滚动条到元素左边的距离，单位为像素。scrollLeft 属性的默认值为 0。 Element 对象的 scrollTop 属性表示滚动条到元素顶部的距离，单位为像素。scrollHeight 属性的默认值为 0。 判断元素内容是否滚动到底 如果元素内容滚动到底的话，如下等式返回的结果为 true，否则返回为 false: element.scrollHeight - element.scrollTop === element.clientHeight 获取指定元素的定位父元素 Element 对象提供的 offsetParent 属性用于返回一个指向最近的包含该元素的定位元素。其语法结构如下: var parentObj = element.offsetParent; 上述语法结构中，作为返回值的 parentObj 表示一个指向最近的包含该元素的定位元素。 值得注意的是: 如果祖先元素中没有开始定位，则 offsetParent 为 body 元素。 我们可以通过以下示例代码，学习 offsetParent 属性的使用: #parent { position: relative; } var btn = document.getElementById('btn'); console.log(btn.offsetParent); offsetParent 属性的浏览器兼容性 在不同浏览器中，对 offsetParent 属性的支持情况也有所不同: 在 Webkit 中，如果元素为隐藏的（该元素或其祖先元素的 style.display 为 \"none\"），或者该元素的 style.position被设为 \"fixed\"，则该属性返回 null。 在 IE 9 中，如果该元素的 style.position 被设置为 \"fixed\"，则该属性返回 null。（display:none 无影响。） 获取指定元素的定位相关属性 与开启定位相关的属性还有以下几种: 指定元素的 offsetWidth 和 offsetHeight 属性分别表示该元素的布局宽度和布局高度，其中包含边框、内边距、滚动条和 CSS 设置的宽度或高度的值。 指定元素的 offsetLeft 和 offsetTop 属性分别表示该元素距离定位父元素左边界和上边界的距离。 值得注意的是: offsetWidth、offsetHeight、offsetLeft 和 offsetTop 属性的值都是整数。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-09-19 22:12:10 "},"27-what-is-event/":{"url":"27-what-is-event/","title":"第一节 什么是事件","keywords":"","body":"所谓事件，就是浏览器告知 JavaScript 程序用户的行为。例如用户点击了 HTML 页面中的某个按钮，或者用户输入用户名或密码等操作。 如下示例代码，演示了如何通过事件完成用户点击按钮后的逻辑: 按钮 var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } 根据上述示例代码，具体执行流程如下: 事件类型 事件根据使用的场景不同，可以分为如下几种: 依赖于设备的输入事件：键盘事件和鼠标事件，这些事件都是直接和设备相关的。 独立于设备的输入事件：例如 click 事件等，这些事件并没有直接与设备相关。 用户界面的相关事件：用户界面事件属于较高级的事件，一般多用于表单中的组件。 状态变化的相关事件：这些事件与用户行为无关，而是由网络或浏览器触发的。 特定 API 事件：这些事件多用于特定场景的实现，例如 HTML5 中提供的拖放 API 中的事件等。 与错误处理的相关事件 键盘事件 键盘事件，主要是指当用户操作电脑键盘时所触发的事件。主要的键盘事件如下: 事件名称 描述 keydown 用户按下一个按键。 keypress 用户按下并释放一个按键。如果该按键不是修饰键时，触发该事件。 keyup 用户释放一个按键。 值得注意的是: 如果是切换指示灯的状态，如Caps Lock键，Num Lock键和Scroll Lock键。这些按键仅发送 keydown 事件和 keyup 事件。 鼠标事件 鼠标事件，主要是指当用户操作电脑鼠标时所触发的事件。主要的鼠标事件如下: 事件名称 描述 mousedown 用户按下鼠标按键。 mouseup 用户释放鼠标按钮。 mouseover 用户移动鼠标到指定元素上。 mousemove 用户鼠标移动。 mouseout 用户将鼠标从指定元素上移除。 独立于设备的输入事件 独立于设备的事件，主要是指当这些事件没有与指定设备相关联。具有如下几种: 事件名称 描述 click 用户点击一下。 dblclick 用户连续点击两下。 contextmenu 用户点击鼠标右键打开上下文菜单。 状态变化的相关事件 状态变化的相关事件，主要是指网络或浏览器的状态发生改变。具有如下几种: 事件名称 描述 load 表示 HTML 页面或图片加载完毕。 unload 表示离开或关闭 HTML 页面。 resize 表示浏览器窗口被重新调整的大小。 scroll 表示 HTML 页面滚动。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-01 21:13:33 "},"28-register-event/":{"url":"28-register-event/","title":"第二节 注册事件","keywords":"","body":"注册事件 所谓注册事件，就是将 JavaScript 函数与指定的事件相关联，被绑定的函数成为该事件的句柄。当该事件被触发时，绑定的函数会被调用。 注册事件具有以下三种方式实现: HTML 页面元素提供的事件属性 DOM 标准规范中 HTML 相关对象提供的事件属性 通过向 HTML 页面中指定元素添加事件监听器 HTML 元素的事件属性 HTML 页面的元素提供了一系列的标准事件属性，通过这些事件属性可以实现注册事件的功能。 例如以下代码示例，演示了如何通过 HTML 元素的事件属性完成注册事件: 按钮 function clickBtn(){ console.log('你终于点中了我...'); } 值得注意的是: 这种方式并没有将 HTML 结构与行为有效地分离。 DOM 对象的事件属性 通过 DOM 标准规范中的 Document 对象定位 HTML 页面的元素，所返回的 DOM 对象提供了一系列的事件属性，通过这些事件属性可以实现注册事件的功能。 例如以下代码示例，演示了如何通过 DOM 对象的事件属性完成注册事件: 按钮 var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } 通过 DOM 对象的事件属性方式注册事件，是不允许重复注册的。如果以这种方式为某个元素注册相同事件多次的话，只有最后一次注册的函数有效。 例如以下代码示例: var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } btn.onclick = function(){ console.log('你又点中了我...'); } 事件监听器 DOM 标准规范提供的 addEventListener() 方法，调用该方法表示向指定元素添加事件监听器。 addEventListener() 方法的语法格式如下: element.addEventListener(eventName, functionName, capture) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 为元素指定具体的事件名称（例如单击事件是 click 等） functionName 注册事件的句柄 capture 设置事件是捕获阶段还是冒泡阶段。false 为默认值，表示冒泡阶段 如下示例代码，是 DOM 对象的事件属性的实现方式: 按钮 var btn = document.getElementById('btn'); btn.onclick = function(){ console.log('你终于点中了我...'); } 使用 addEventListener() 方法可以将上述代码进行改写: 按钮 var btn = document.getElementById('btn'); btn.addEventListener('click',function(){ console.log('你终于点中了我...'); }); 事件监听器的优点 addEventListener() 方法是 DOM 的标准规范所提供的注册事件监听器的方法，它的优点包括以下几点: 它允许某个 HTML 页面的元素在绑定一个事件的同时，注册多个事件的句柄（事件处理函数）。 它提供了一种更精细的手段控制事件的触发阶段（是捕获阶段还是冒泡阶段）。 IE 8及之前版本浏览器的事件监听器 在 IE 8 及之前版本的浏览器，并不支持 addEventListenter() 方法添加事件监听器。而是使用 attachEvent() 方法进行添加。 attachEvent() 方法的语法格式如下: element.attachEvent(eventName, functionName) 参数名称 描述 eventName 为元素指定具体的事件名称（例如单击事件是 click 等） functionName 注册事件的句柄 我们可以通过以下示例代码，学习如何使用 attachEvent() 方法: 按钮 \u000b var btn = document.getElementById('btn'); btn.attachEvent('onclick',function(){ console.log('你终于点中了我...'); }); 监听器的浏览器兼容方案 在实际开发中，我们既要兼容 IE 8及之前版本的浏览器，也要兼容其他浏览器。所以，我们可以自定义事件注册方法实现: function bind(elem, event, callback){ // 判断是否存在 addEventListener if (elem.addEventListener){ elem.addEventListener(event, callback, false); }else{ elem.attachEvent('on' + event, callback); } } 事件监听器中的 this 当使用 addEventListener() 方法为某个 HTML 页面元素注册事件的时候，this 就指代注册事件的元素。 例如以下示例代码: btn.addEventListener('click',function(){ console.log(btn.textContent); }); 上述代码可以使用 this 改写如下方式: btn.addEventListener('click',function(){ console.log(this.textContent); }); 当使用 attachEvent() 方法为某个 HTML 页面元素注册事件的时候，this 指代的是 window 对象，而不是注册事件的元素。 例如以下示例代码: var btn = document.getElementById('btn'); btn.attachEvent('onclick',function(){ console.log(this); }); 上述代码输出的结果如下: [Object window] 监听器的浏览器兼容优化方案 由于 addEventListener() 方法中的 this 与 attachEvent() 方法中的 this 的含义不同，我们需要将监听器的浏览器兼容方案进行优化: function bind(elem, event, callback){ // 判断是否存在 addEventListener if (elem.addEventListener){ elem.addEventListener(event, callback, false); }else{ elem.attachEvent('on' + event, function(){ // 将 this 的指向修改为注册事件的元素 callback.call(elem); }); } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-20 11:46:24 "},"29-remove-register-event/":{"url":"29-remove-register-event/","title":"第三节 移除注册事件","keywords":"","body":"移除注册事件 事件监听器的内存问题 我们先来看一个示例代码: var els = document.getElementsByTagName('*'); for(var i=0 ; i 上述示例代码中，每次循环都会创建一个新的匿名函数。这样的结果会导致占用的存储空间很大。 我们再来看一个示例代码: var els = document.getElementsByTagName('*'); function processEvent(e){ /*do something*/ } for(var i=0 ; i 上述示例代码中，每次循环使用之前定义的函数。这样的结果是占用的存储空间更小。 移除注册事件 在上述两段示例代码中，除了占用存储空间大小的区别以外，第一个示例代码由于使用了匿名函数，是无法调用 removeEventListener() 方法移除注册的事件的。相反，第二个示例代码是允许的。 removeEventListener() 方法的语法格式如下: element.removeEventListener(eventName, functionName, capture) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 表示移除的事件名称（例如单击事件是 click 等） functionName 移除注册事件的句柄（之前使用 addEventListener() 方法定义的） capture 设置事件是捕获阶段还是冒泡阶段。false 为默认值，表示冒泡阶段 我们可以通过以下示例代码，学习如何使用 removeEventListener() 方法: 按钮 var btn = document.getElementById('btn'); function listener(){ console.log('你终于点中了我...'); } btn.addEventListener('click',listener); btn.removeEventListener('click',listener); detachEvent() 方法 移除注册事件在 IE 8 及之前版本的浏览器都不支持 removeEventListener() 方法，而是单独提供了 detachEvent() 方法。其语法结构如下: element.detachEvent(eventName, functionName) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 表示移除的事件名称（例如单击事件是 click 等） functionName 移除注册事件的句柄（之前使用 attachEvent() 方法定义的） 我们可以通过以下示例代码，学习如何使用 detachEvent() 方法: 按钮 var btn = document.getElementById('btn'); function listener(){ console.log('你终于点中了我...'); } btn.attachEvent('click',listener); btn.detachEvent('click',listener); 移除注册事件的浏览器兼容解决方案 与注册事件相似，移除注册事件在实际开发中，同样需要兼容各大浏览器，具体解决方案如下: function unbind(elem, eventName, functionName){ if (elem.removeEventListener){ elem.removeEventListener(eventName, functionName); } else { elem.detachEvent('on'+eventName, functionName); } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-20 13:18:34 "},"30-event-object/":{"url":"30-event-object/","title":"第四节 Event 事件对象","keywords":"","body":"Event 事件对象 什么是事件对象 为 HTML 页面中的元素注册事件时，事件的处理函数具体一个参数，该参数就是 Event 事件对象。 Event 事件对象中包含了该事件的信息，以及该事件发生在哪个元素上。 element.addEventListener(eventName, function(event){ // event 就是事件对象 }, capture) 值得注意的是: 当事件发生时， Event 事件对象会被创建并依次传递给事件监听器。 由于 Event 事件对象是事件处理函数的参数，所以参数名允许自定义的。 Event 事件对象的属性或方法 属性或方法 描述 target 表示触发当前事件的 HTML 元素 currentTarget 表示注册当前事件的 HTML 元素 srcElement IE 8 及之前版本浏览器支持，表示触发当前事件的 HTML 元素 returnValue IE 8 及之前版本浏览器支持，表示取消当前事件的默认行为 cancelBubble IE 8 及之前版本浏览器支持，表示阻止当前事件的冒泡行为 preventDefault() 表示取消当前事件的默认行为 stopPropagation() 表示阻止当前事件的冒泡行为 IE 8及之前版本浏览器的 Event 事件对象 IE 8 及之前版本浏览器，HTML 页面元素注册事件时，Event 事件对象并不是作为事件的处理函数的参数，而是作为 window 对象的属性存在的。 我们可以通过以下示例代码进行测试: 按钮 var btn = document.getElementById('btn'); btn.attachEvent('onclick',function(){ console.log(window.event); }); Event 事件对象的兼容解决方案 如果 HTML 页面元素注册事件是通过 HTML 页面元素的事件属性或者 DOM 提供的事件属性方式实现的话，Event 事件对象的兼容解决方案如下代码示例: event = event || window.event; 或者，也可以通过如下代码示例解决: if (!event){ event = window.event; } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-20 13:39:21 "},"31-get-target-element/":{"url":"31-get-target-element/","title":"第五节 获取目标元素","keywords":"","body":"获取目标元素 Event 事件对象的 target 属性 Event 事件对象提供了 target 属性，用于获取触发当前事件的 HTML 元素。 链接 var li = document.getElementById('li'); li.addEventListener('click',function(event){ console.log(event.target) }); 上述示例代码运行效果如右图所示: 如果点击 元素，则 元素触发事件，target 属性表示 元素。 链接 如果点击 元素，则 元素触发事件，target 属性表示 元素。 链接 如果点击 元素，则 元素触发事件，target 属性表示 元素。 链接 target 属性的浏览器的兼容性 IE 8 及之前版本浏览器并不支持 target 属性，而是提供了与 target 属性作用相同的 srcElement 属性。 链接 var li = document.getElementById('li'); li.attachEvent('onclick',function(event){ event = event || window.event; console.log(event.srcElement) }); Event 事件对象的 currentTarget 属性 Event 事件对象提供了 currentTarget 属性，用于获取注册当前事件的 HTML 元素。 链接 var li = document.getElementById('li'); li.addEventListener('click',function(event){ console.log(event.currentTarget) }); 上述示例代码，无论点击 、 或者 元素，currentTarget 属性得到都是注册事件的 元素。 事件处理函数中的 this 事件处理函数中的 this，作用与事件对象的 currentTarget 属性相同，可以获取注册当前事件的 HTML 元素。 链接 var li = document.getElementById('li'); li.addEventListener('click',function(event){ console.log(this) }); currentTarget 属性的浏览器兼容性 IE 8 及之前版本的浏览器并不支持 Event 事件对象的 currentTarget 属性，并且也没有提供相应的属性或方法。监听器 attachEvent() 方法中的 this 表示 window 对象，也不是注册事件的 HTML 元素。 function bind(elem, event, callback){ if (elem.addEventListener){ elem.addEventListener(event, callback, false); }else{ elem.attachEvent('on' + event, function(){ callback.call(elem); }); } } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-21 08:53:25 "},"32-prevent-default/":{"url":"32-prevent-default/","title":"第六节 阻止默认行为","keywords":"","body":"阻止默认行为 什么是默认行为 所谓默认行为，就是指 HTML 元素不借助 JavaScript 逻辑原本具有的动态效果。例如以下 HTML 元素: 元素的跳转功能 元素中点击 提交按钮时，提交表单功能 输入框的输入文本内容功能 单选框或复选框的切换选项功能 Event 事件对象的 preventDefault() 方法 Event 事件对象提供了 preventDefault() 方法，用于阻止 HTML 元素的默认行为。 链接 var a = document.getElementById('a'); a.onclick = function(event){ event.preventDefault(); } 浏览器的兼容性 IE 8 及之前版本的浏览器，并不支持 preventDefault() 方法，而是提供了 returnValue 属性实现相同功能。 链接 var a = document.getElementById('a'); a.onclick = function(event){ if (event.preventDefault){ event.preventDefault(); }else{ event.returnValue = false; } } return false 语句 事件的处理函数中，我们也可以使用 return false 语句阻止默认行为。 return false 语句除了具有阻止默认行为功能之外，编写在 return false 语句后面的 JavaScript 代码并不会被执行。 值得注意的是: return false 语句只有在 DOM 规范标准的事件属性有效，而在事件监听器的处理函数中是无效的。 var a = document.getElementById('a'); a.onclick = function(event){ return false; } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-21 11:12:24 "},"33-mouse-coordinate/":{"url":"33-mouse-coordinate/","title":"第七节 获取鼠标坐标","keywords":"","body":"获取鼠标坐标 Event 事件对象提供了触发注册事件时，有关鼠标的坐标值相关属性: pageX 和 pageY: 表示鼠标在整个页面中的位置。如果页面过大（存在滚动条），部分页面可能存在可视区域之外。 clientX 和 clientY: 表示鼠标在整个可视区域中的位置。 screenX 和 screenY: 表示鼠标在整个屏幕中的位置。从屏幕（不是浏览器）的左上角开始计算。 offsetX 和 offsetY: 表示鼠标相对于定位父元素的位置。 鼠标相对页面的坐标 pageX 和 pageY 属性表示鼠标相对于页面的坐标值，我们可以通过以下示意图更好地理解: 值得注意的是: 部分页面可能会在浏览器可视窗口的外面。如果部分页面存在可视窗口外面的话，相对于页面的坐标值会大于相对于可视窗口的坐标值。 鼠标相对可视窗口的坐标 clientX 和 clientY 属性表示相对于可视窗口的坐标值，我们可以通过以下示意图更好地理解: 值得注意的是: clientX 和 clientY 表示鼠标相对于浏览器可视窗口的坐标，是不包含浏览器的地址栏、工具栏等区域的。 鼠标相对屏幕的坐标 screenX 和 screenY 属性表示相对于电脑屏幕的坐标值，我们可以通过以下示意图更好地理解: 鼠标相对目标元素的坐标 offsetX 和 offsetY 属性表示相对于目标元素的坐标值，我们可以通过以下示意图更好地理解: offsetX 和 offsetY 表示鼠标相对于目标元素的偏移量。这里的目标元素指的是触发注册事件的元素。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-23 08:59:17 "},"34-event-flow/":{"url":"34-event-flow/","title":"第八节 事件流","keywords":"","body":"事件流 什么是事件流 所谓事件流，就是当触发某个元素的事件时，事件会按照 DOM 树结构进行传播，传播的过程分为捕获阶段、目标阶段和冒泡阶段三个阶段。 捕获阶段：该阶段是由网景公司提出的。按照 DOM 树结构由 document 对象向下的顺序传播，直到目标元素为止。 目标阶段：该阶段就是指目标元素触发当前事件。 冒泡阶段：该阶段是由微软公司提出的，按照 DOM 树结构由目标元素向上的顺序传播，直到 document 对象为止。 事件监听器 事件监听器 addEventListener() 方法的第三个参数的作用，就是设置当前注册的事件是捕获阶段还是冒泡阶段。 element.addEventListener(eventName, functionName, capture) 上述语法结构中，参数的具体说明如下: 参数名称 描述 eventName 为元素指定具体的事件名称（例如单击事件是 click 等） functionName 注册事件的句柄 capture 设置事件是捕获阶段还是冒泡阶段。false 为默认值，表示冒泡阶段 捕获阶段 如果将事件监听器方法 addEventListener() 的第三个参数的只设置为 true，即为捕获阶段。 如下代码示例，使用事件监听器方法同时为三个 元素注册相同事件: 值得注意的是: IE 8 及之前版本的浏览器不支持捕获阶段。 我们可以通过以下示意图更好地理解事件的捕获阶段: 冒泡阶段 如果将事件监听器方法 addEventListener() 的第三个参数的只设置为 false，即为冒泡阶段。 如下代码示例，使用事件监听器方法同时为三个 元素注册相同事件: 我们可以通过以下示意图更好地理解事件的冒泡阶段: 取消事件冒泡 当元素注册事件设置为冒泡阶段时，可以通过 Event 事件对象的 stopPropagation() 方法取消事件冒泡。 var d1 = document.getElementById('d1'); d1.addEventListener('click',function(){ alert(this.id); },false); var d2 = document.getElementById('d2'); d2.addEventListener('click',function(){ alert(this.id); },false); var d3 = document.getElementById('d3'); d3.addEventListener('click',function(event){ alert(this.id); event = event || window.event; event.stopPropagation(); },false); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-23 13:25:40 "},"35-event-delegate/":{"url":"35-event-delegate/","title":"第九节 事件委托","keywords":"","body":"事件委托 什么是事件委托 当为大量的 HTML 元素注册相同事件，并且事件的句柄逻辑完全相同时，会造成页面速度下降。不过，事件流允许在这些 HTML 元素的共同父级元素注册事件。这种方式被称为事件委托。 按钮 按钮 按钮 var btn = document.getElementById('parent'); btn.addEventListener('click', function(event){ if (event.target.nodeName === 'BUTTON'){ alert('我是一个链接.') } }); 事件委托的优势 适用于新创建的元素 如果向 DOM 树结构中添加新的元素，那么不需要再向这个新元素注册相同事件。因为注册事件已经委托给了该元素的祖先元素完成。 简化逻辑代码 这种方式只需要祖先元素一次注册事件，而不需要分别为大量元素注册事件。使得逻辑代码的性能提高，也更加容易维护。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-23 13:27:44 "}}