{"version":3,"sources":["../src/position-map-text-to-markdown.js"],"names":["mapPosition","getAllIndexes","matchText","allText","indexes","i","indexOf","push","text","parentText","markdown","markdownAST","markdownSource","markdownText","toString","matchIndexes","length","getOriginalInfo","index","startIndex","originalIndexFromIndex","endIndex","startPosition","originalPositionFromIndex","endPosition","slice","range","loc","start","end","matchResults","map","matchIndex"],"mappings":"AAAA;AACA;;;;;QAgCgBA,W,GAAAA,W;;AA/BhB;;AACA;;;;;;AAEA,SAASC,aAAT,CAAuBC,SAAvB,EAAkCC,OAAlC,EAA2C;AACvC,QAAMC,UAAU,EAAhB;AACA,QAAIC,IAAI,CAAC,CAAT;AACA,WAAO,CAACA,IAAIF,QAAQG,OAAR,CAAgBJ,SAAhB,EAA2BG,IAAI,CAA/B,CAAL,MAA4C,CAAC,CAApD,EAAuD;AACnDD,gBAAQG,IAAR,CAAaF,CAAb;AACH;AACD,WAAOD,OAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;AAoBO,SAASJ,WAAT,OAAqD;AAAA,QAA9BQ,IAA8B,QAA9BA,IAA8B;AAAA,QAAxBC,UAAwB,QAAxBA,UAAwB;AAAA,QAAZC,QAAY,QAAZA,QAAY;;;AAExD,QAAMC,cAAc,0BAAMD,QAAN,CAApB;AACA,QAAME,iBAAiB,mCAAiBD,WAAjB,CAAvB;AACA,QAAME,eAAeD,eAAeE,QAAf,EAArB;AACA,QAAMC,eAAed,cAAcO,IAAd,EAAoBK,YAApB,CAArB;AACA;AACA,QAAIE,aAAaC,MAAb,KAAwB,CAA5B,EAA+B;AAC3B,eAAO,EAAP,CAD2B,CAChB;AACd;AACD;AACA,QAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,KAAD,EAAQF,MAAR,EAAmB;AACvC,YAAMG,aAAaP,eAAeQ,sBAAf,CAAsCF,KAAtC,CAAnB;AACA,YAAMG,WAAWF,aAAaH,MAA9B;AACA,YAAMM,gBAAgBV,eAAeW,yBAAf,CAAyCL,KAAzC,CAAtB;AACA,YAAMM,cAAcZ,eAAeW,yBAAf,CAAyCL,QAAQF,MAAjD,CAApB;AACA,eAAO;AACHN,sBAAUA,SAASe,KAAT,CAAeN,UAAf,EAA2BE,QAA3B,CADP;AAEHK,mBAAO,CAACP,UAAD,EAAaE,QAAb,CAFJ;AAGHM,iBAAK;AACDC,uBAAON,aADN;AAEDO,qBAAKL;AAFJ;AAHF,SAAP;AAQH,KAbD;AAcA,QAAMM,eAAef,aAAagB,GAAb,CAAiB,UAACC,UAAD,EAAgB;AAClD,eAAOf,gBAAgBe,UAAhB,EAA4BxB,KAAKQ,MAAjC,CAAP;AACH,KAFoB,CAArB;AAGA,WAAOc,YAAP;AACH","file":"position-map-text-to-markdown.js","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\nimport { parse } from \"markdown-to-ast\";\nimport StringSource from \"textlint-util-to-string\";\n\nfunction getAllIndexes(matchText, allText) {\n    const indexes = [];\n    let i = -1;\n    while ((i = allText.indexOf(matchText, i + 1)) !== -1) {\n        indexes.push(i);\n    }\n    return indexes;\n}\n/**\n *\n * @param {string} text\n * @param {string} [parentText]\n * @param {string} markdown\n * @returns {{\n *  markdown:string,\n *  range: [number, number],\n *  loc: {\n *    start: {\n *       line:number,\n *       column:number\n *    },\n *    end: {\n *       line:number,\n *       column:number\n *    }\n * }\n * }[]}\n */\nexport function mapPosition({ text, parentText, markdown }) {\n\n    const markdownAST = parse(markdown);\n    const markdownSource = new StringSource(markdownAST);\n    const markdownText = markdownSource.toString();\n    const matchIndexes = getAllIndexes(text, markdownText);\n    // const parentMatchIndex = markdownText.indexOf(parentText);\n    if (matchIndexes.length === 0) {\n        return []; // no match\n    }\n    // get original info\n    const getOriginalInfo = (index, length) => {\n        const startIndex = markdownSource.originalIndexFromIndex(index);\n        const endIndex = startIndex + length;\n        const startPosition = markdownSource.originalPositionFromIndex(index);\n        const endPosition = markdownSource.originalPositionFromIndex(index + length);\n        return {\n            markdown: markdown.slice(startIndex, endIndex),\n            range: [startIndex, endIndex],\n            loc: {\n                start: startPosition,\n                end: endPosition\n            }\n        };\n    };\n    const matchResults = matchIndexes.map((matchIndex) => {\n        return getOriginalInfo(matchIndex, text.length);\n    });\n    return matchResults;\n}"]}