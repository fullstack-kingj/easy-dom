// MIT Â© 2017 azu
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.findAllPositions = findAllPositions;

var _markdownToAst = require("markdown-to-ast");

var _textlintUtilToString = require("textlint-util-to-string");

var _textlintUtilToString2 = _interopRequireDefault(_textlintUtilToString);

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getAllIndexes(matchText, allText) {
    var indexes = [];
    var i = -1;
    while ((i = allText.indexOf(matchText, i + 1)) !== -1) {
        indexes.push(i);
    }
    return indexes;
}
/**
 * get markdown location info that match `text`
 * @param {string} text
 * @param {string} markdown
 * @returns {{
 *  markdown:string,
 *  range: [number, number],
 *  loc: {
 *    start: {
 *       line:number,
 *       column:number
 *    },
 *    end: {
 *       line:number,
 *       column:number
 *    }
 * }
 * }[]}
 */
function findAllPositions(_ref) {
    var text = _ref.text,
        markdown = _ref.markdown;


    var markdownAST = (0, _markdownToAst.parse)(markdown);
    var markdownRawSource = new _structuredSource2.default(markdown);
    var markdownSource = new _textlintUtilToString2.default(markdownAST);
    var markdownText = markdownSource.toString();
    var matchIndexes = getAllIndexes(text, markdownText);
    // const parentMatchIndex = markdownText.indexOf(parentText);
    if (matchIndexes.length === 0) {
        return []; // no match
    }
    // get original info
    var getOriginalInfo = function getOriginalInfo(index, length) {
        var startIndex = markdownSource.originalIndexFromIndex(index);
        var endIndex = markdownSource.originalIndexFromIndex(index + length, true);
        var startPosition = markdownRawSource.indexToPosition(startIndex);
        var endPosition = markdownRawSource.indexToPosition(endIndex);
        return {
            markdown: markdown.slice(startIndex, endIndex),
            range: [startIndex, endIndex],
            loc: {
                start: startPosition,
                end: endPosition
            }
        };
    };
    return matchIndexes.map(function (matchIndex) {
        return getOriginalInfo(matchIndex, text.length);
    });
}
//# sourceMappingURL=position-map-text-to-markdown.js.map