{"version":3,"sources":["../src/position-map-text-to-markdown.js"],"names":["findAllPositions","getAllIndexes","matchText","allText","indexes","i","indexOf","push","text","markdown","markdownAST","markdownRawSource","markdownSource","markdownText","toString","matchIndexes","length","getOriginalInfo","index","startIndex","originalIndexFromIndex","endIndex","startPosition","indexToPosition","endPosition","slice","range","loc","start","end","map","matchIndex"],"mappings":"AAAA;AACA;;;;;QAgCgBA,gB,GAAAA,gB;;AA/BhB;;AACA;;;;AACA;;;;;;AAEA,SAASC,aAAT,CAAuBC,SAAvB,EAAkCC,OAAlC,EAA2C;AACvC,QAAMC,UAAU,EAAhB;AACA,QAAIC,IAAI,CAAC,CAAT;AACA,WAAO,CAACA,IAAIF,QAAQG,OAAR,CAAgBJ,SAAhB,EAA2BG,IAAI,CAA/B,CAAL,MAA4C,CAAC,CAApD,EAAuD;AACnDD,gBAAQG,IAAR,CAAaF,CAAb;AACH;AACD,WAAOD,OAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;AAmBO,SAASJ,gBAAT,OAA8C;AAAA,QAAlBQ,IAAkB,QAAlBA,IAAkB;AAAA,QAAZC,QAAY,QAAZA,QAAY;;;AAEjD,QAAMC,cAAc,0BAAMD,QAAN,CAApB;AACA,QAAME,oBAAoB,+BAAeF,QAAf,CAA1B;AACA,QAAMG,iBAAiB,mCAAiBF,WAAjB,CAAvB;AACA,QAAMG,eAAeD,eAAeE,QAAf,EAArB;AACA,QAAMC,eAAed,cAAcO,IAAd,EAAoBK,YAApB,CAArB;AACA;AACA,QAAIE,aAAaC,MAAb,KAAwB,CAA5B,EAA+B;AAC3B,eAAO,EAAP,CAD2B,CAChB;AACd;AACD;AACA,QAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,KAAD,EAAQF,MAAR,EAAmB;AACvC,YAAMG,aAAaP,eAAeQ,sBAAf,CAAsCF,KAAtC,CAAnB;AACA,YAAMG,WAAWT,eAAeQ,sBAAf,CAAsCF,QAAQF,MAA9C,EAAsD,IAAtD,CAAjB;AACA,YAAMM,gBAAgBX,kBAAkBY,eAAlB,CAAkCJ,UAAlC,CAAtB;AACA,YAAMK,cAAcb,kBAAkBY,eAAlB,CAAkCF,QAAlC,CAApB;AACA,eAAO;AACHZ,sBAAUA,SAASgB,KAAT,CAAeN,UAAf,EAA2BE,QAA3B,CADP;AAEHK,mBAAO,CAACP,UAAD,EAAaE,QAAb,CAFJ;AAGHM,iBAAK;AACDC,uBAAON,aADN;AAEDO,qBAAKL;AAFJ;AAHF,SAAP;AAQH,KAbD;AAcA,WAAOT,aAAae,GAAb,CAAiB,UAACC,UAAD,EAAgB;AACpC,eAAOd,gBAAgBc,UAAhB,EAA4BvB,KAAKQ,MAAjC,CAAP;AACH,KAFM,CAAP;AAGH","file":"position-map-text-to-markdown.js","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\nimport { parse } from \"markdown-to-ast\";\nimport StringSource from \"textlint-util-to-string\";\nimport TextSource from \"structured-source\";\n\nfunction getAllIndexes(matchText, allText) {\n    const indexes = [];\n    let i = -1;\n    while ((i = allText.indexOf(matchText, i + 1)) !== -1) {\n        indexes.push(i);\n    }\n    return indexes;\n}\n/**\n * get markdown location info that match `text`\n * @param {string} text\n * @param {string} markdown\n * @returns {{\n *  markdown:string,\n *  range: [number, number],\n *  loc: {\n *    start: {\n *       line:number,\n *       column:number\n *    },\n *    end: {\n *       line:number,\n *       column:number\n *    }\n * }\n * }[]}\n */\nexport function findAllPositions({ text, markdown }) {\n\n    const markdownAST = parse(markdown);\n    const markdownRawSource = new TextSource(markdown);\n    const markdownSource = new StringSource(markdownAST);\n    const markdownText = markdownSource.toString();\n    const matchIndexes = getAllIndexes(text, markdownText);\n    // const parentMatchIndex = markdownText.indexOf(parentText);\n    if (matchIndexes.length === 0) {\n        return []; // no match\n    }\n    // get original info\n    const getOriginalInfo = (index, length) => {\n        const startIndex = markdownSource.originalIndexFromIndex(index);\n        const endIndex = markdownSource.originalIndexFromIndex(index + length, true);\n        const startPosition = markdownRawSource.indexToPosition(startIndex);\n        const endPosition = markdownRawSource.indexToPosition(endIndex);\n        return {\n            markdown: markdown.slice(startIndex, endIndex),\n            range: [startIndex, endIndex],\n            loc: {\n                start: startPosition,\n                end: endPosition\n            }\n        };\n    };\n    return matchIndexes.map((matchIndex) => {\n        return getOriginalInfo(matchIndex, text.length);\n    });\n}"]}